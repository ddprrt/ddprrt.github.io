<!doctype html>
<html>
<head>
</head>
<body>
    <p>TypeScript is a structural type system. This means as long as your data structure satisfies a contract,<br>
TypeScript will allow it. Even if you have too many keys declared.</p>
<pre><code class="language-javascript">type Person = {
  first: string, last: string
}

declare function savePerson(person: Person);

const tooFew = { first: 'Stefan' };
const exact = { first: 'Stefan', last: 'Baumgartner' }
const tooMany = { first: 'Stefan', last: 'Baumgartner', age: 37 }

savePerson(tooFew); // ğŸ’¥ doesn't work
savePerson(exact); // âœ… satisfies the contract
savePerson(tooMany); // âœ… satisfies the contract
</code></pre>
<p>This complements the way JavaScript works really well and gives you both flexibility and type safety.<br>
There are some scenarios where you might want the exact shape of an object. E.g.<br>
when you send data to backend that errors if it gets too much information.</p>
<pre><code class="language-javascript">savePerson(tooMany); // âœ… satisfies the contract, ğŸ’¥ bombs the backend
</code></pre>
<p>In a JS world, always make sure to explicitly send payloads in scenarios like that,<br>
donâ€™t rely on types alone. But while types canâ€™t help you getting communication 100% correct,<br>
we can get a little compilation time help to make sure we donâ€™t stray off our own path.<br>
All with the help of conditional types.</p>
<p>First, we check if the object we want to validate matches the original shape:</p>
<pre><code class="language-javascript">type ValidateShape&lt;T, Shape&gt; = 
  T extends Shape ? ...
</code></pre>
<p>With that call we make sure that the object we pass as parameter is a subtype of <code>Shape</code>.<br>
Then, we check for any extra keys:</p>
<pre><code class="language-diff">type ValidateShape&lt;T, Shape&gt; =
  T extends Shape ? 
+ Exclude&lt;keyof T, keyof Shape&gt; extends never ? ...
</code></pre>
<p>So how does this work? <code>Exclude&lt;T, U&gt;</code> is defined as <code>T extends U ? never : T</code>. We pass<br>
in the keys the object to validate and the shape. Letâ€™s say <code>Person</code> is our shape, and<br>
<code>tooMany = { first: 'Stefan', last: 'Baumgartner', age: 37 }</code> is the object we want<br>
to validate. This are our keys:</p>
<pre><code class="language-javascript">keyof Person = 'first' | 'last'
keyof typeof tooMany = 'first' | 'last' | 'age'
</code></pre>
<p><code>'first'</code> and <code>'last'</code> are in both union types, so they return <code>never</code>, <code>age</code> returns<br>
itself because it isnâ€™t available in <code>Person</code>:</p>
<pre><code class="language-javascript">keyof Person = 'first' | 'last'
keyof typeof tooMany = 'first' | 'last' | 'age'

Exclude&lt;keyof typeof tooMany, keyof Person&gt; = 'age';
</code></pre>
<p>Is it an exact match, <code>Exclude&lt;T, U&gt;</code> returns <code>never</code>:</p>
<pre><code class="language-javascript">keyof Person = 'first' | 'last'
keyof typeof exact = 'first' | 'last'

Exclude&lt;keyof typeof exact, keyof Person&gt; = never;
</code></pre>
<p>In <code>ValidateShape</code> we check if <code>Exclude</code> extends <code>never</code>, meaning we donâ€™t have any extrac keys.<br>
If this condition is true, we return the type we want to validate.<br>
In all other conditions, we return <code>never</code>:</p>
<pre><code class="language-diff">type ValidateShape&lt;T, Shape&gt; =
  T extends Shape ? 
  Exclude&lt;keyof T, keyof Shape&gt; extends never ? 
+ T : never : never;
</code></pre>
<p>Letâ€™s adapt our original function:</p>
<pre><code class="language-javascript">declare function savePerson&lt;T&gt;(person: ValidateShape&lt;T, Person&gt;): void;
</code></pre>
<p>With that, itâ€™s impossible to pass objects that donâ€™t exactly match the<br>
shape of the type we expect:</p>
<pre><code class="language-javascript">savePerson(tooFew); // ğŸ’¥ doesn't work
savePerson(exact); // âœ… satisfies the contract
savePerson(tooMany); // ğŸ’¥ doesn't work
</code></pre>
<p>Thereâ€™s a <a href="https://www.typescriptlang.org/play/index.html#code/C4TwDgpgBAChBOBnA9gOygXigbwLACgooAzASyWAC4pFh5TUBzAGigBsBDW62+pggL4ECoSFABqHNqQAmHYBADKdAK4BjYCvgQAPABVWy+OuAA+TFAJE9UCAA8FqGYihGTUAPyXCUAKJ21NhUZXQBrCBBkYigDKHDI6LcNc3tHZyhUCAA3BE8YqGpMnPgCjOyEAG5hfBDAjm0SFVQNUjQaDhy4JDR9UwAKSG7UaklpOQUkzW19Vi6UVFMASmos5Fkq-AI1NFooYGRkADEIAHcLbBJybigAcmUIYg5UG6gBDe3UXfsODXPLimodwUj2erE41xuACEOCoALaMerATLwF5CfAfXb7ZAAWSeID+ZABt3uIJuYK4VFu0LhCPgSIQZKgHEYEGoAGYAOyvaqIDoQOZoPpY44nRYVKAAeglUEAvBuAUp2oDJkBBEM9gFATsh4KECLzOgh5n1vhoxZLpYBQcnawFIiDIKr2AAtoB86D9gLq+QLUEKDrjUCBTVLZQqlSq1RqtTrNvggA">playground for you</a> to fiddle around. This helper wonâ€™t get you around runtime checks, but it is a helping hand during development.</p>
<p>//include helper/include-by-tag.html tag=â€œTypeScriptâ€ title=â€œMore articles about TypeScriptâ€</p>

</body>
</html>
