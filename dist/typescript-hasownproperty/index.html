<!doctype html>
<html>
<head>
</head>
<body>
    <p>TypeScript‚Äôs control flow analysis lets you narrow down from a broader type to a more narrow type:</p>
<pre><code class="language-javascript">function print(msg: any) {
  if(typeof msg === 'string') {
    // We know msg is a string
    console.log(msg.toUpperCase()) // üëç
  } else if (typeof msg === 'number') {
    // I know msg is a number
    console.log(msg.toFixed(2)) // üëç
  }
}
</code></pre>
<p>This is a type-safety check in JavaScript, and TypeScript benefits from that. However, there are some cases where<br>
TypeScript <em>at the time of this writing</em> needs a little bit more assistance from us.</p>
<p>Let‚Äôs assume you have a JavaScript object where you don‚Äôt know if a certain property exists. The object might be <code>any</code> or <code>unknown</code>. In JavaScript, you would check for properties like that:</p>
<pre><code class="language-javascript">if(typeof obj === 'object' &amp;&amp; 'prop' in obj) {
  //it's safe to access obj.prop
  console.assert(typeof obj.prop !== 'undefined') // But TS doesn't know :-(
}

if(typeof obj === 'object' &amp;&amp; obj.hasOwnProperty('prop')) {
  //it's safe to access obj.prop
  console.assert(typeof obj.prop !== 'undefined') // But TS doesn't know :-(
}
</code></pre>
<p>At the moment, TypeScript isn‚Äôt able to extend the type of <code>obj</code> with a <code>prop</code>. Even though this works with JavaScript.</p>
<p>We can, however, write a little helper function to get correct typings:</p>
<pre><code class="language-javascript">function hasOwnProperty&lt;X extends {}, Y extends PropertyKey&gt;
  (obj: X, prop: Y): obj is X &amp; Record&lt;Y, unknown&gt; {
  return obj.hasOwnProperty(prop)
}
</code></pre>
<p>If you don‚Äôt want to know how this works, copy it and be happy. If you want to know more, let‚Äôs check out what‚Äôs happening:</p>
<ol>
<li>Our <code>hasOwnProperty</code> function has two generics:
<ol>
<li><code>X extends {}</code> makes sure we use this method only on objects</li>
<li><code>Y extends PropertyKey</code> makes sure that the key is either <code>string | number | symbol</code>. <code>PropertyKey</code> is a builtin type.</li>
</ol>
</li>
<li>There‚Äôs no need to explicitly define the generics, they‚Äôre getting inferred by usage.</li>
<li><code>(obj: X, prop: Y)</code>: We want to check if <code>prop</code> is a property key of <code>obj</code></li>
<li>The return type is a <a href="/typescript-type-predicates/">type predicate</a>. If the method returns <code>true</code>, we can retype any of our parameters. In this case, we say our <code>obj</code> is the original object, with an intersection type of <code>Record&lt;Y, unknown&gt;</code>, the last piece adds the newly found property to <code>obj</code> and sets it to <code>unknown</code>.</li>
</ol>
<p>In use, <code>hasOwnProperty</code> works like that:</p>
<pre><code class="language-javascript">// person is an object
if(typeof person === 'object' 
  // person = { } &amp; Record&lt;'name', unknown&gt;
  // = { } &amp; { name: 'unknown'}
  &amp;&amp; hasOwnProperty(person, 'name') 
  // yes! name now exists in person üëç
  &amp;&amp; typeof person.name === 'string' 
  ) {
    // do something with person.name, which is a string
  }
</code></pre>
<p>That‚Äôs it! A lovely little helper to make TypeScript understand your code better.<br>
Here‚Äôs a <a href="https://www.typescriptlang.org/play/index.html?ts=3.8-Beta&amp;ssl=6&amp;ssc=1&amp;pln=3&amp;pc=1#code/C4TwDgpgBACgTgezFAvFAzsOBLAdgcygB8pcBXAWwCMI5iMRqEAbAbgCh2AzM3AY2DYEuKAAsAhugDyAd1zwktUAB4AGlAgAPYBFwATdFADeAXwA0UAJobtug7ERgAfAAoEVAFYAuKKothHH0sASh93DyhsQ3UAMigAJQg+BDg9ZUsLXgBrXAQ5J2N2KCg4CGAyOBFwgDoJaTkFSDhQFwCkYPYTTj0k5nFSqGTcTCgQH1N2bC4oFzrZeUclEBcQCwByXHEKCDXgqBi4uYbF5uXVqDXMMi4uXb2jIsjpl1BIBGmQas3t1BQ0S6weHwa32cU+6Huj2Kjy6XXYQA">playground</a> for you to fiddle around.</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
