<!doctype html>
<html>
<head>
</head>
<body>
    <p>When you work on modern JS apps you most likely use Webpack. Webpack always looked like a very complicated build tool to me, until I realised that it‚Äôs nothing but a JavaScript bundler. A JavaScript bundler that allows you to bundle <em>everything</em>! CSS, Markdown, SVGs, JPEGs, you name. It exists and helps the web, you can bundle it.</p>
<h2>Import everything</h2>
<p>Once I got that Webpack configs weren‚Äôt that scary anymore. It‚Äôs loaders loading stuff in JavaScript. Stuff that wouldn‚Äôt be loadable otherwise. Cool! You define the assets to load in the JavaScript file you develop.</p>
<pre><code class="language-javascript">// like this
import &quot;./Button.css&quot;;

// or this
import styles from &quot;./Button.css&quot;;
</code></pre>
<p>Especially the last one lets you use CSS class names like object properties, how nice!</p>
<p>If you are like me and use TypeScript for all you code, you will  quickly realise that TypeScript is not so happy with non-TypeScript or non-JavaScript imports.</p>
<h2>TypeScript‚Äôs modules</h2>
<p>TypeScript itself does neither load other modules, nor does it bundle JavaScript into files. TypeScript uses modules to get more type information for you and to sanity check your code to make sure you didn‚Äôt have any error.</p>
<p>What should TypeScript do with something that isn‚Äôt a JS or TS module? Exactly. Throwing an error! <em>Could not find module</em>.</p>
<p>There is a way to solve this.</p>
<h2>Ambient module declarations</h2>
<p>TypeScript supports so called ‚Äú<strong>ambient module declarations</strong>‚Äù. Even for a module that is not ‚Äúphysically‚Äù there, but in the environment or reachable via tooling. One example are Node‚Äôs main built-in modules, like <code>url</code>, <code>http</code> or <code>path</code>:</p>
<pre><code class="language-javascript">declare module &quot;path&quot; {
  export function normalize(p: string): string;
  export function join(...paths: any[]): string;
  export var sep: string;
}
</code></pre>
<p><em>The example above comes from the docs</em>. This is great for modules where we know the exact name. We can use the same pattern also for wildcard patterns. Let‚Äôs declare a generic ambient module for all our CSS files:</p>
<pre><code class="language-javascript">declare module '*.css' {
  // wait for it
}
</code></pre>
<p>The pattern is ready. This listens to all CSS files we want to import. What we expect is a list of class names that we can add to our components. Since we don‚Äôt know which classes are defined in the CSS files, let‚Äôs go with an object that accepts every string key and returns a string.</p>
<pre><code class="language-javascript">declare module '*.css' {
  interface IClassNames {
    [className: string]: string
  }
  const classNames: IClassNames;
  export default classNames;
}
</code></pre>
<p>That‚Äôs all we need to make our files compile again. The only downside is that we can‚Äôt use the exact class names to get auto completion and similar benefits. There is a <a href="https://www.npmjs.com/search?q=css%20modules%20typescript%20loader">ton üèãÔ∏è‚Äç‚ôÄÔ∏è of packages üì¶ on NPM</a>, that deal with that. Pick yours!</p>
<h2>MDX</h2>
<p>It‚Äôs a bit easier if we want to import something like MDX into our modules. MDX lets us write Markdown which parses to regular React (or JSX) components. This sounds super weird at first but it‚Äôs actually a ton of fun to use. Let‚Äôs define that in an ambient module for our webpack loader.</p>
<p>We expect a functional component (that we can pass props to) that returns a JSX element:</p>
<pre><code class="language-javascript">declare module '*.mdx' {
  let MDXComponent: (props) =&gt; JSX.Element;
  export default MDXComponent;
}
</code></pre>
<p>And voil√†: Everything perfectly usable:</p>
<pre><code class="language-javascript">import About from '../articles/about.mdx';

function App() {
  return &lt;&gt;
    &lt;About/&gt;
  &lt;/&gt;
}
</code></pre>
<h2>What if we don‚Äôt know the result</h2>
<p>If you don‚Äôt know what to expect, make your life easy:</p>
<pre><code class="language-javascript">declare module '*.svg';
</code></pre>
<h2>Where to put ambient modules</h2>
<p>To make ambient modules available to your app, I recommend creating an <code>@types</code> folder somewhere in your project (probably root level). There you can put any amount of <code>.d.ts</code> files with your module definitions in. Add a referal to your <code>tsconfig.json</code> and TypeScript knows what to do üëç</p>
<pre><code class="language-javascript">{
  ...
  &quot;compilerOptions&quot;: {
    ...
    &quot;typeRoots&quot;: [
      &quot;./node_modules/@types&quot;,
      &quot;./@types&quot;
    ],
    ...
  }
}

</code></pre>
<p>As <a href="https://twitter.com/martin_hotell">Martin</a> suggests, a good pattern is to create folders with the package name, and put <code>index.d.ts</code> files in them. But that‚Äôs up to you!</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
