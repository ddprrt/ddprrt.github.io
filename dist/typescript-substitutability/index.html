<!doctype html>
<html>
<head>
</head>
<body>
    <p>When starting with TypeScript it took not much time to stumble upon some of the type system’s odds. Odds that make a lot of sense if you take a closer look. In this article I want to show you why and how in some cases, TypeScript allows non-matching method signatures.</p>
<h2>Functions with fewer parameters</h2>
<p>With TypeScript, it’s fine to pass functions to other functions that have fewer parameters as specified. Look at the following example.</p>
<p><code>fetchResults</code> has one parameter, a callback function. The method gets data from somewhere, and afterwards executes a callback. The callback’s method signature has two paramters. <code>statusCode</code> (type <code>number</code>) and results (array of <code>number</code>). You see the call in line 4.</p>
<pre><code class="language-javascript">function fetchResults(callback: (statusCode: number, results: number[]) =&gt; void) {
  // get results from somewhere
  ...
  callback(200, results); // this is line 4
}
</code></pre>
<p>We call <code>fetchResults</code> with the following <code>handler</code> function. The method signature is different, though. It omits the second paramter <code>results</code>.</p>
<pre><code class="language-javascript">function handler(statusCode: number) {
  // evaluate the status code
  ...
}

fetchResults(handler); // compiles, no problem!
</code></pre>
<p>This still compiles with no errors or warnings whatsoever. This felt odd first, especially when comparing it to other languages. Why are non-matching method signatures accepted? But TypeScript is a superset of JavaScript. And if you think hard about it, we do this all the time in JavaScript!</p>
<p>Take <code>express</code>, the server side framework, for example. The callback methods usually have three parameters:</p>
<ul>
<li><code>req</code>: the original request</li>
<li><code>res</code>: the server response</li>
<li><code>next</code>: passing over to the next middleware in the stack.</li>
</ul>
<p>We can omit the <code>next</code> parameter if there’s no need to call the next middleware.</p>
<p>The power lies in the callback function. The callback function knows best what to do with all the parameters handed over. And if there’s no need for a certain parameter, it’s safe to skip it.</p>
<h2>Return type void</h2>
<p>If a function type specifies return type <code>void</code>, functions with a different, more specific, return type are also accepted. Again, the example from before:</p>
<pre><code class="language-javascript">function fetchResults(callback: (statusCode: number, results: number[]) =&gt; void) {
  // get results from somewhere
  ...
  callback(200, results);
}
</code></pre>
<p>The callback function has two parameters in its signature, and the return type is <code>void</code>. Let’s look at an adapted handler function from before:</p>
<pre><code class="language-javascript">function handler(statusCode: number): boolean {
  // evaluate the status code
  ...
  return true;
}

fetchResults(handler); // compiles, no problem!
</code></pre>
<p>Even though the method signature declares a boolean return type, the code still compiles. Even though the method signatures don’t match. This is special when declaring a <code>void</code> return type. The original caller <code>fetchResults</code> does not expect a return value when calling the callback.</p>
<p>TypeScript would throw an error if we did assign the result to a variable or constant inside <code>fetchResult</code>.</p>
<pre><code class="language-javascript">function fetchResults(callback: (statusCode: number, results: number[]) =&gt; void) {
  // get results from somewhere
  ...
  const didItWork = callback(200, results); // ⚡️ compile error!
}
</code></pre>
<p>That’s why we can pass callbacks with any return type. Even if the callback returns something, this value isn’t used and goes into the void.</p>
<p>The power lies within the calling function. The calling function knows best what to expect from the callback function. And if the calling function doesn’t require a return value at all from the callback, anything goes!</p>
<h2>Substitutability</h2>
<p>TypeScript calls this feature “substitutability”. The ability to substitute one thing for another, wherever it makes sense. This might strike you odd at first. But especially when you work with libraries that you didn’t author, you will find this feature very usable.</p>
<p>//include helper/include-by-tag.html tag=“TypeScript” title=“More articles about TypeScript”</p>

</body>
</html>
