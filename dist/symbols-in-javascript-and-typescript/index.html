<!doctype html>
<html>
<head>
</head>
<body>
    <p><code>symbol</code> is a primitive data type in JavaScript and TypeScript, which, amongst other things,<br>
can be used for object properties. Compared to <code>number</code> and <code>string</code>, <code>symbol</code>s have some unique<br>
features that make them stand out.</p>
<h2>Symbols in JavaScript</h2>
<p>Symbols can be created using the <code>Symbol()</code>  factory function:</p>
<pre><code class="language-javascript">const TITLE = Symbol('title')
</code></pre>
<p><code>Symbol</code> has no constructor function. The parameter is an optional description. By calling the<br>
factory function, <code>TITLE</code> is assigned the unique value of this freshly created symbol. This<br>
symbol is now unique, distinguishable from all other symbols and doesn‚Äôt clash with any other<br>
symbols that have the same description.</p>
<pre><code class="language-javascript">const ACADEMIC_TITLE = Symbol('title')
const ARTICLE_TITLE = Symbol('title')

if(ACADEMIC_TITLE === ARTICLE_TITLE) {
  // THis is never true
}
</code></pre>
<p>The description helps you to get info on the Symbol during development time:</p>
<pre><code class="language-javascript">console.log(ACADEMIC_TITLE.description) // title
console.log(ACADEMIC_TITLE.toString()) // Symbol(title)
</code></pre>
<p>Symbols are great if you want to have comparable values that are exclusive and unique. For<br>
runtime switches or mode comparisons:</p>
<pre><code class="language-javascript">// A shitty logging framework
const LEVEL_INFO = Symbol('INFO')
const LEVEL_DEBUG = Symbol('DEBUG')
const LEVEL_WARN = Symbol('WARN')
const LEVEL_ERROR = Symbol('ERROR')

function log(msg, level) {
  switch(level) {
    case LEVEL_WARN: 
      console.warn(msg); break
    case LEVEL_ERROR: 
      console.error(msg); break;
    case LEVEL_DEBUG: 
      console.log(msg); 
      debugger; break;
    case LEVEL_INFO:
      console.log(msg);
  }
}
</code></pre>
<p>Symbols also work as property keys, but are not iterable, which is great for serialisation</p>
<pre><code class="language-javascript">const print = Symbol('print')

const user = {
  name: 'Stefan',
  age: 37,
  [print]: function() {
    console.log(`${this.name} is ${this.age} years old`)
  }
}

JSON.stringify(user) // { name: 'Stefan', age: 37 }
user[print]() // Stefan is 37 years old
</code></pre>
<h2>Global symbols registry</h2>
<p>There‚Äôs a global symbols registry that allows you to access tokens across your whole<br>
application.</p>
<pre><code class="language-javascript">Symbol.for('print') // creates a global symbol

const user = {
  name: 'Stefan',
  age: 37,
  // uses the global symbol
  [Symbol.for('print')]: function() {
    console.log(`${this.name} is ${this.age} years old`)
  }
}
</code></pre>
<p>First call to <code>Symbol.for</code> creates a symbol, second call uses the same symbol.<br>
If you store the symbol value in a variable and want to know the key, you can use <code>Symbol.keyFor()</code></p>
<pre><code class="language-javascript">const usedSymbolKeys = []

function extendObject(obj, symbol, value) {
  //Oh, what symbol is this?
  const key = Symbol.keyFor(symbol)
  //Alright, let's better store this
  if(!usedSymbolKeys.includes(key)) {
    usedSymbolKeys.push(key)
  }
  obj[symnbol] = value
}

// now it's time to retreive them all
function printAllValues(obj) {
  usedSymbolKeys.forEach(key =&gt; {
    console.log(obj[Symbol.for(key)])
  })
}
</code></pre>
<p>Nifty!</p>
<h2>Symbols in TypeScript</h2>
<p>TypeScript has full support for symbols, and they are prime citizens in the type system.<br>
<code>symbol</code> itself is a data type annotation for all possible symbols. See the <code>extendObject</code><br>
function from earlier on. To allow for all symbols to extend our object, we can use the<br>
<code>symbol</code> type:</p>
<pre><code class="language-javascript">const sym = Symbol('foo')

function extendObject(obj: any, sym: symbol, value: any) {
  obj[sym] = value
}

extendObject({}, sym, 42) // Works with all symbols
</code></pre>
<p>There‚Äôs also the sub-type <code>unique symbol</code>. A <code>unique symbol</code> is closely tied to the<br>
declaration, only allowed in const declarations and references this exact symbol, and nothing else.</p>
<p>You can think of a nominal type in TypeScript for a very nominal value in JavaScript.</p>
<p>To get to the type of <code>unique symbol</code>s, you need to use the typeof operator.</p>
<pre><code class="language-javascript">const PROD: unique symbol = Symbol('Production mode')
const DEV: unique symbol = Symbol('Development mode')

function showWarning(msg: string, mode: typeof DEV | typeof PROD) {
 // ...
}
</code></pre>
<p>At time of writing, the only possible nominal type in TypeScript‚Äôs structural type system.</p>
<p>Symbols stand at the intersection between nominal and opaque types in TypeScript and JavaScript.<br>
And are the closest things we get to nominal type checks at runtime. A good way to recreate constructs<br>
like <code>enum</code>s for example.</p>
<h2>Runtime Enums</h2>
<p>An interesting use case of symbols is to re-create <code>enum</code> like behaviour at runtime in JavaScript.<br>
<code>enum</code>s in TypeScript are opaque. This effectively means that you can‚Äôt assign string values to <code>enum</code><br>
types, because TypeScript treats them as unique:</p>
<pre><code class="language-javascript">enum Colors {
  Red = 'Red',
  Green = 'Green',
  Blue = 'Blue',
}

const c1: Colors = Colors.Red;
const c2: Colors = 'Red'; // üí£ No direct assigment possible
</code></pre>
<p>Very interesting if you do comparisons:</p>
<pre><code class="language-javascript">
enum Moods {
  Happy = 'Happy',
  Blue = 'Blue'
}

// üí£ This condition will always return 'false' since the
// types 'Moods.Blue' and 'Colors.Blue' have no overlap.
if(Moods.Blue === Colors.Blue) {
  // Nope
}
</code></pre>
<p>Even with the same value types, being in an enum makes them unique enough for<br>
TypeScript to consider them not comparable.</p>
<p>In JavaScript land, we can create enums like that with symbols. See the colors of the<br>
rainbow an black in the following example. Our ‚Äúenum‚Äù <code>Colors</code> includes only symbols<br>
which are colors, not black:</p>
<pre><code class="language-javascript">// All Color symbols
const COLOR_RED: unique symbol = Symbol('RED')
const COLOR_ORANGE: unique symbol = Symbol('ORANGE')
const COLOR_YELLOW: unique symbol = Symbol('YELLOW')
const COLOR_GREEN: unique symbol = Symbol('GREEN')
const COLOR_BLUE: unique symbol = Symbol('BLUE')
const COLOR_INDIGO: unique symbol = Symbol('INDIGO')
const COLOR_VIOLET: unique symbol = Symbol('VIOLET')
const COLOR_BLACK: unique symbol = Symbol('BLACK')

// All colors except Black
const Colors = {
  COLOR_RED,
  COLOR_ORANGE,
  COLOR_YELLOW,
  COLOR_GREEN,
  COLOR_BLUE,
  COLOR_INDIGO,
  COLOR_VIOLET
} as const;
</code></pre>
<p>We can use this symbols just as we would use <code>enum</code>s:</p>
<pre><code class="language-javascript">function getHexValue(color) {
  switch(color) {
    case Colors.COLOR_RED: return '#ff0000'
    //...
  }
}
</code></pre>
<p>And the symbols can‚Äôt be compared:</p>
<pre><code class="language-javascript">const MOOD_HAPPY: unique symbol = Symbol('HAPPY')
const MOOD_BLUE: unique symbol = Symbol('BLUE')

// All colors except Black
const Moods = {
  MOOD_HAPPY,
  MOOD_BLUE
} as const;

// üí£ This condition will always return 'false' since the types 
// 'typeof MOOD_BLUE' and 'typeof COLOR_BLUE' have no overlap.
if(Moods.MOOD_BLUE === Colors.COLOR_BLUE) {
  // Nope
}
</code></pre>
<p>There are a few TypeScript annotations we want to add:</p>
<ol>
<li>We declare all symbol keys (and values) as <code>unique symbols</code>, meaning<br>
the constant we assign our symbols to can never be changed.</li>
<li>We declare our ‚Äúenum‚Äù objects <code>as const</code>. With that, TypeScript goes from<br>
setting the type to allow for every symbol, to just allow the exact same<br>
symbols we defined.</li>
</ol>
<p>This allows us to get more type safety when defining our symbol ‚Äúenums‚Äù for<br>
function declarations. We start with a helper type for getting all value types<br>
from an object.</p>
<pre><code class="language-javascript">type ValuesWithKeys&lt;T, K extends keyof T&gt; = T[K];
type Values&lt;T&gt; = ValuesWithKeys&lt;T, keyof T&gt;
</code></pre>
<p>Remember, we use <code>as const</code>, which means that our values are narrowed down to<br>
the exact value type (e.g. type is <code>COLOR_RED</code>) instead of their overarching type (<code>symbol</code>).</p>
<p>With that, we can declare our function like that:</p>
<pre><code class="language-javascript">function getHexValue(color: Values&lt;typeof Colors&gt;) {
  switch(color) {
    case COLOR_RED:
      // super fine, is in our type
    case Colors.COLOR_BLUE:
      // also super fine, is in our type
      break;
    case COLOR_BLACK: 
      // what? What is this??? TypeScript errors üí•
      break;
  }
}
</code></pre>
<p>You can get rid of the helper and const context, if you use symbol keys and values<br>
instead of only symbol values:</p>
<pre><code class="language-javascript">const ColorEnum = {
  [COLOR_RED]: COLOR_RED,
  [COLOR_YELLOW]: COLOR_YELLOW,
  [COLOR_ORANGE]: COLOR_ORANGE,
  [COLOR_GREEN]: COLOR_GREEN,
  [COLOR_BLUE]: COLOR_BLUE,
  [COLOR_INDIGO]: COLOR_INDIGO,
  [COLOR_VIOLET]: COLOR_VIOLET,
}

function getHexValueWithSymbolKeys(color: keyof typeof ColorEnum) {
  switch(color) {
    case ColorEnum[COLOR_BLUE]:
      // üëç
      break;
    case COLOR_RED:
      // üëç
      break;
    case COLOR_BLACK: 
      // üí•
      break;
  }
}
</code></pre>
<p>This gives you both type safety at compile time through TypeScript <code>unique symbol</code>s,<br>
and actual type safety at runtime with the unique characteristics of JavaScript‚Äôs<br>
<code>Symbol</code>s.</p>
<p>And, als always: <a href="https://www.typescriptlang.org/play/index.html#code/LAKFGMHsDsGcBcAEBhA8gGVQJQPpYKIAiAXIgK7QCWAjmQKaKwCeAtgEaQA2iAvIgMqsOnABQByNJlwFCYgJQQYCFBmw5sAQQByAcXykKNeoyFdeA06Imrcm3fnmK4SSWoCa+dJgDqBqrQZmdjM+QWCrV1wPL1RvRxAoZxUpHB0CfC0-I0DLczDhcUjU9K14xOUigCF0AFV9cn9jIOE8y0KbHGq6sqUXDoBJLUJ+nVQsgJNw1vD2lMHh0Z6kooA1fox8ABVxptzQtusUtY3NpYqO6o1kAGkdnKn9mcO1S5v4pwquSAAnWHMAb1AiGSahkABogSDbFhtHoISBgUVoj54YiOml8BlUVDOrV8NiivMRqgCR1jugtqAAL6IACGf3K8AA3KBQPAmAAHBgrWmceiwbyUeAAC2udCYsAAPJswYhrog6AAPeB0aAAEz+AGtxZAAGaITYAPnMmwA2tcALoskDsrmIHl8uhSo3mB38wUisUS6Wy7VMPUGw2skC6ijgeCUGCIADmdHgAAklW66CIoJwfqRk1LbXQA8gvr9DXJEICEYwAO5C8DC1MF4ul4HA8D0hj59O-AB0VTxxEhjcQAHoB33G2xvnRaZrrf3m7BWxd0FdbogR8Ch6vEGOJ1PIVTqcHYwmk7z6CI2z9YF2F3UFGAEr1EABZVCoQg4eMaAAKn7cd0mLUeAoxA-b83DOJBn1fXE6j-ZoQgsJ4ugcW9QCHRANE4bg0wvBVFXAOgOSQSpOFpcBNQ+CDIEgDUAUhSC3xAn9sXo6D8GpOkGV6a1QEoXUREfKiNQ7FikN4Hg+HPTtuxvEtIX3O9GRQAt8GgMgWFostTSKGQLVIbSiGxLSOmRWJdJxEzvEMoo7D0MzrJhewrPREo7OczEtCclIkNcry8U8tQiVGHyAqGYl-NwcktmCiL1gpGV5NAUNoHDSNoBjONE0VZMPWFfIuC9WBa3bUg-QDHM82U1SWHrSFYEreBqyKn4arLJsWyU9sVLUozfLqXSN3XVrR3HSdp0bWd5xSGReyGtdh1mzcRp3IaJpxV5lwG+b+2BLdRt3akgA">A playground</a> for you to fiddle around.</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
