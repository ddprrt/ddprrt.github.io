&lt;p&gt;One of the major changes in Gulp 4 is the new task execution system. In this&lt;br&gt;
article, I want to show you what’s new and how you can migrate the best.&lt;/p&gt;
&lt;h2&gt;Task execution chains in Gulp 3&lt;/h2&gt;
&lt;p&gt;Before we take a look at the new, let’s see what was there previously. Usually,&lt;br&gt;
Gulp would allow defining a dependency to a task. It would make sure that this&lt;br&gt;
dependency task gets executed before the original task gets triggered. Look&lt;br&gt;
at this code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// Per default, start scripts and styles
gulp.task(&#39;default&#39;, [&#39;scripts&#39;, &#39;styles&#39;], function() {...});

// Both scripts and styles call clean
gulp.task(&#39;styles&#39;, [&#39;clean&#39;], function() {...});
gulp.task(&#39;scripts&#39;, [&#39;clean&#39;], function() {...});

// Clean wipes out the build directory
gulp.task(&#39;clean&#39;, function() {...});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;A very basic Gulpfile. You want to build scripts and styles, but before you do&lt;br&gt;
so, clean the original build directory so you can start at a blank slate. The&lt;br&gt;
syntax is very elegant and similar to those of other build tools.&lt;/p&gt;
&lt;p&gt;When Gulp’s started, it creates a dependency tree like the one below.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wp-content/uploads/2015/folie1.jpg&quot; alt=&quot;How Gulp 3 orders tasks&quot;&gt;&lt;/p&gt;
&lt;p&gt;So it realizes that &lt;em&gt;clean&lt;/em&gt; is a dependency of two tasks. In this way, it makes&lt;br&gt;
sure that it is executed only once.&lt;/p&gt;
&lt;p&gt;One thing to keep in mind there: All those tasks are executed for maximum&lt;br&gt;
concurrency. So the execution order is something like shown in the next&lt;br&gt;
figure.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wp-content/uploads/2015/folie2.jpg&quot; alt=&quot;Gulp 3 dependency check and execution order&quot;&gt;&lt;/p&gt;
&lt;p&gt;First clean, then &lt;em&gt;scripts&lt;/em&gt; and &lt;em&gt;styles&lt;/em&gt; in parallel, and after that we can&lt;br&gt;
execute the default task function.&lt;/p&gt;
&lt;p&gt;There are however several problems with it:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Once you define the dependency chain in that way, the execution of&lt;br&gt;
this dependency is mandatory.&lt;/li&gt;
&lt;li&gt;This is a particular problem if you want to have watchers that listen on one&lt;br&gt;
type only. Imagine triggering the &lt;em&gt;styles&lt;/em&gt; task every time you change one of your&lt;br&gt;
CSS files. It would execute first &lt;em&gt;clean&lt;/em&gt;, and then &lt;em&gt;styles&lt;/em&gt;, practically&lt;br&gt;
deleting your efforts from “script”.&lt;/li&gt;
&lt;li&gt;Also, there is currently no way of executing tasks sequentially. The “first clean,&lt;br&gt;
then task” style of executing can be done just with dependencies, leading to the&lt;br&gt;
problems above.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;One Gulp plugin that tried to bridge the gap here was &lt;a href=&quot;https://www.npmjs.com/package/run-sequence&quot;&gt;run-sequence&lt;/a&gt;.&lt;br&gt;
It’s functionality is now part of Gulp 4 with the addition of the new&lt;br&gt;
task manager “Undertaker”.&lt;/p&gt;
&lt;h2&gt;Task execution functions for Gulp 4&lt;/h2&gt;
&lt;p&gt;Gulp 4 drops the dependency parameter completely and replaces them with execution functions&lt;br&gt;
that can be used instead:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gulp.series&lt;/code&gt; for sequential execution&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gulp.parallel&lt;/code&gt; for parallel execution.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Each of those functions allow for parameters of the following kind:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The name of the task to execute&lt;/li&gt;
&lt;li&gt;Another function to execute&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So if you want to execute &lt;em&gt;styles&lt;/em&gt; and &lt;em&gt;scripts&lt;/em&gt; in parallel, you can write&lt;br&gt;
something like this:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;gulp.task(&#39;default&#39;, gulp.parallel(&#39;scripts&#39;, &#39;styles&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The cool thing is, &lt;code&gt;gulp.parallel&lt;/code&gt; and &lt;code&gt;gulp.series&lt;/code&gt; are functions, and&lt;br&gt;
accept functions. So you can nest them as much as you want, creating&lt;br&gt;
complex execution orders:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wp-content/uploads/2015/folie4.jpg&quot; alt=&quot;Parallel and series nested&quot;&gt;&lt;/p&gt;
&lt;p&gt;The execution of the graph above is: A, then B, then C and D parallel, then E.&lt;/p&gt;
&lt;h2&gt;Migration&lt;/h2&gt;
&lt;p&gt;Since we aim for the maximum currency, one would think to replace all dependency&lt;br&gt;
arrays with &lt;code&gt;gulp.parallel&lt;/code&gt; functions, like that:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;gulp.task(&#39;styles&#39;, gulp.parallel(&#39;clean&#39;, function() {...}));
gulp.task(&#39;scripts&#39;, gulp.parallel(&#39;clean&#39;, function() {...}));

gulp.task(&#39;clean&#39;, function() {...});

gulp.task(&#39;default&#39;, gulp.parallel(&#39;scripts&#39;, &#39;styles&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The first problem with this approach is that &lt;code&gt;clean&lt;/code&gt; always gets executed with the&lt;br&gt;
actual task that creates the output. In a concurrent world, this can mean that we&lt;br&gt;
immediately delete the files we created. We don’t want that. So let’s exchange the&lt;br&gt;
tasks that are meant to be executed after another with &lt;code&gt;gulp.series&lt;/code&gt;.&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;gulp.task(&#39;styles&#39;, gulp.series(&#39;clean&#39;, function() {...}));
gulp.task(&#39;scripts&#39;, gulp.series(&#39;clean&#39;, function() {...}));

gulp.task(&#39;clean&#39;, function() {...});

gulp.task(&#39;default&#39;, gulp.parallel(&#39;scripts&#39;, &#39;styles&#39;));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Better. However, there are still problems. First of all, the dependency is still&lt;br&gt;
hard-wired: “Clean” gets called every time we call &lt;em&gt;scripts&lt;/em&gt; or &lt;em&gt;styles&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Second, Gulp 4 does not have any dependency check (because they aren’t dependencies)&lt;br&gt;
anymore, so our execution tree looks something like that:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wp-content/uploads/2015/folie3.jpg&quot; alt=&quot;The problem replacing the arrays with gulp.parallel&quot;&gt;&lt;/p&gt;
&lt;p&gt;“Clean” gets executed twice. This is fatal, because it might actually be that&lt;br&gt;
results from one task would be deleted by the next execution tree.&lt;/p&gt;
&lt;p&gt;To make a good and robust migration, without hard wires and by keeping the original&lt;br&gt;
execution order, do the following. Look at the original execution order:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wp-content/uploads/2015/folie2.jpg&quot; alt=&quot;Gulp 3 dependency check and execution order&quot;&gt;&lt;/p&gt;
&lt;p&gt;The execution order of the tasks in the original tree are: &lt;em&gt;clean&lt;/em&gt;, &lt;em&gt;styles&lt;/em&gt; and&lt;br&gt;
&lt;em&gt;scripts&lt;/em&gt; in parallel, and then the &lt;em&gt;default&lt;/em&gt; task.&lt;/p&gt;
&lt;p&gt;Each step that can be done in concurrent will be combined in a &lt;code&gt;gulp.parallel&lt;/code&gt;&lt;br&gt;
function. The others are ordered in a &lt;code&gt;gulp.series&lt;/code&gt; function. Like that:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/wp-content/uploads/2015/folie5.jpg&quot; alt=&quot;Our original execution chain restructured&quot;&gt;&lt;/p&gt;
&lt;p&gt;The accompanying source code:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;// The tasks don&#39;t have any dependencies anymore
gulp.task(&#39;styles&#39;, function() {...});
gulp.task(&#39;scripts&#39;, function() {...});

gulp.task(&#39;clean&#39;, function() {...});

// Per default, start scripts and styles
gulp.task(&#39;default&#39;,
  gulp.series(&#39;clean&#39;, gulp.parallel(&#39;scripts&#39;, &#39;styles&#39;),
  function() {...}));
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;The execution order at &lt;em&gt;default&lt;/em&gt; stays the same as previously, but all the&lt;br&gt;
other tasks can be used on their own, without being bound on dependencies.&lt;/p&gt;
&lt;p&gt;Hurray for flexibility!&lt;/p&gt;

