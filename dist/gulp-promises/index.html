&lt;p&gt;The Gulp task system does not only work with streams alone, but also with other&lt;br&gt;
asynchronous patterns. One of those are well known Promises! Find out how we can&lt;br&gt;
use two Promise-based tools to create a thorough file sync between two folders.&lt;/p&gt;
&lt;h2&gt;File sync: Copy new files to a destination&lt;/h2&gt;
&lt;p&gt;Think of a build system where you store your files in a source directory, but have&lt;br&gt;
every computation done in a working or build directory. Gradle for instance is one&lt;br&gt;
of those tools that recommend you to work this way. And for good reason: You never&lt;br&gt;
touch the source, making it more robust to integrate in CI environments. A pull from&lt;br&gt;
master doesn’t kill your intermediates. And on the other: Your intermediates or results&lt;br&gt;
don’t interfere with everything new coming from your Git branch.&lt;/p&gt;
&lt;p&gt;So, what we are aiming for is a call that copies all the files from a source directory&lt;br&gt;
to a destination directory, where Gulp awaits to execute your build tasks. With the&lt;br&gt;
concepts we learned from &lt;a href=&quot;/gulp-4-incremental-builds/&quot;&gt;incremental builds&lt;/a&gt; we are able&lt;br&gt;
to create the first part: Copying new files from a source to a destination:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;var globArray = [ ... ]  // all the files you want to read

gulp.task(&#39;copy-src&#39;, function(){
  return gulp.src(globArray, { cwd: &#39;../../src/&#39; })
    .pipe(newer(&#39;.&#39;))
    .pipe(gulp.dest(&#39;.&#39;));
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;That takes care of all the new files or changed files, without copying&lt;br&gt;
anything that doesn’t need to be there. That’s half the battle. What about the&lt;br&gt;
files that have been copied from a previous run, but then got removed? If you&lt;br&gt;
really want to have a direct copy of your source directory, you also want to&lt;br&gt;
remove them in your destination directory.&lt;/p&gt;
&lt;h2&gt;Getting the diff between two directories&lt;/h2&gt;
&lt;p&gt;To get the difference between the source and destination directory we have&lt;br&gt;
several possibilities, even Gulp plugins to use. However, most of them feel&lt;br&gt;
kind of clumsy or “do too much”, something that a Gulp plugin should never do.&lt;/p&gt;
&lt;p&gt;So, why not do it on our own? Here’s the plan:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Read both source and destination directory.&lt;/li&gt;
&lt;li&gt;Compare both lists and find the difference&lt;/li&gt;
&lt;li&gt;Delete the files that are left, hence: The ones that are not in the source&lt;br&gt;
directory anymore.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;We have some Promised-based Node modules for that:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;globby&lt;/code&gt;: Creates a list of file paths based on a glob. Something very similar&lt;br&gt;
to Gulp.s&lt;/li&gt;
&lt;li&gt;&lt;code&gt;del&lt;/code&gt;: A module that deletes files based on a glob. This is actually the&lt;br&gt;
preferred way by Gulp to take care of deleting files.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;And here’s how we are going to combine them:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;gulp.task(&#39;diff&#39;, function() {
  return Promise.all([                                    /* 1 */
    globby(globArray, { nodir: true }),                   /* 2 */
    globby(globArray, { cwd: &#39;../../src/&#39;, nodir: true }) /* 3 */
  ]).then(function(paths) {
    return paths[0].filter(function(i) {                  /* 4 */
      return paths[1].indexOf(i) &amp;lt; 0;
    });
  }).then(function(diffs) {                               /* 5 */
    return del(diffs);
  });
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Let’s go through this one by one.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;We use &lt;code&gt;Promise.all&lt;/code&gt; to run two Promise-based glob calls against&lt;br&gt;
our file system.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;globby&lt;/code&gt; by the one and only Sindre Sorhus allows for&lt;br&gt;
Gulp-style globbing (including directories) with Promises. Add the &lt;code&gt;nodir&lt;/code&gt;&lt;br&gt;
parameter to the &lt;code&gt;globby&lt;/code&gt; call to not get directory file handles.&lt;/li&gt;
&lt;li&gt;Do the same for the source directory. We change the working directory to&lt;br&gt;
our source directory. By using the &lt;code&gt;cwd&lt;/code&gt; parameter, the file list has the same&lt;br&gt;
structure as from the first &lt;code&gt;globby&lt;/code&gt; call.&lt;br&gt;
Since we run both Promises with Promise.all, we also get an array of results.&lt;/li&gt;
&lt;li&gt;The array of results contain two arrays of file names. The first one from&lt;br&gt;
the destination, the second one from our source. We use the&lt;br&gt;
&lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&quot;&gt;&lt;code&gt;Array.prototype.filter&lt;/code&gt;&lt;/a&gt; and &lt;a href=&quot;https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf&quot;&gt;&lt;code&gt;Array.prototype.indexOf&lt;/code&gt;&lt;/a&gt; function to compare our results: We filter all elements that are not in our second&lt;br&gt;
array. Note: This procedure might take some time depending on how many file paths you&lt;br&gt;
are going to compare. We are talking seconds here. This is quite some time in&lt;br&gt;
the Gulp world.&lt;/li&gt;
&lt;li&gt;The result of this step is an array with “leftovers”: All those files that have&lt;br&gt;
been removed from the source directory but still exist in our working directory.&lt;br&gt;
We use Sindre Sorhus’ &lt;code&gt;del&lt;/code&gt; module that takes care of this files. It returns also a&lt;br&gt;
Promise, so it’s perfectly usable with the Promise-chain that we made here.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;ES6 fat arrows&lt;/h2&gt;
&lt;p&gt;It’s even more beautiful when you work with ES6 fat arrow functions:&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;language-javascript&quot;&gt;gulp.task(&#39;diff&#39;, function() {
  return Promise.all([
    globby(globArray, { nodir: true }),
    globby(globArray, { cwd: &#39;../../src/&#39;, nodir: true })
  ])
  .then(paths =&amp;gt; paths[0].filter(i =&amp;gt; paths[1].indexOf(i) &amp;lt; 0))
  .then(diffs =&amp;gt; del(diffs))
});
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Nice, clean and totally in tune with Gulp!&lt;/p&gt;
&lt;h2&gt;Bottom line&lt;/h2&gt;
&lt;p&gt;With Gulp you have a vast ecosystem of plugins at your hand. This ecosystem&lt;br&gt;
expands as you can use any stream related tool and wrap it around the Gulp API.&lt;br&gt;
But you are not bound to streams alone. With Promises, any asynchronous code can&lt;br&gt;
work with the Gulp task system! So the amount of tools to choose from grows even&lt;br&gt;
more!&lt;/p&gt;
&lt;h2&gt;Software used:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Node.js: 5.2.0&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/gulp-newer&quot;&gt;&lt;code&gt;gulp-newer&lt;/code&gt;&lt;/a&gt;: 0.5.1&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/del&quot;&gt;&lt;code&gt;del&lt;/code&gt;&lt;/a&gt;: 2.2.0&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/globby&quot;&gt;&lt;code&gt;globby&lt;/code&gt;&lt;/a&gt;: 4.0.0&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Works with both Gulp 3 and Gulp 4. The rest is Node.js native.&lt;/p&gt;

