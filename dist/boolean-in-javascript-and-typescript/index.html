<!doctype html>
<html>
<head>
</head>
<body>
    <p><code>boolean</code> is a fun primitive data type in JavaScript. In TypeScript, it allows for a total of four values<br>
Wait, four?</p>
<h2>Boolean in JavaScript</h2>
<p><code>boolean</code> can take the values of <code>true</code> and <code>false</code>. Values from other types can be truthy or falsy,<br>
like <code>undefined</code> or <code>null</code>.</p>
<pre><code class="language-javascript">let b = true
if(b) console.log('logged')

b = false
if(b) console.log('not logged')

b = undefined
if(b) console.log('not logged')

b = null
if(b) console.log('not logged')
</code></pre>
<p>Values other than <code>undefined</code>, <code>null</code> or <code>false</code> considered falsy are <code>&quot;&quot;</code> (empty string), <code>-0</code> and <code>0</code>, as well as <code>NaN</code>.</p>
<p>To get the boolean value of any value, you can use the <code>Boolean</code> function:</p>
<pre><code class="language-javascript">Boolean(false) // false
Boolean(true) // true
Boolean(&quot;false&quot;) // true ❗️
Boolean(&quot;Hey folks&quot;) // true
Boolean({}) // true
Boolean([]) // true
Boolean(123.4) // true
Boolean(Symbol()) // true
Boolean(function() {}) // true
Boolean(undefined) // false
Boolean(null) // false
Boolean(NaN) // false
Boolean(0) // false
Boolean(&quot;&quot;) // false
</code></pre>
<p>Rule of thumb: All empty values evaluate to <code>false</code>. Empty object <code>{}</code> and<br>
empty array <code>[]</code> (which is an object itself) do have value as they are containers<br>
for other values.</p>
<p>The <code>Boolean</code> function is really good to filter empty values from collections:</p>
<pre><code class="language-javascript">const collection = [
  { name: 'Stefan Baumgartner', age: 37 },
  undefined,
  { name: 'D.', age: 36 },
  false
  { name: 'C.', age: 2},
  false
]

collection.filter(Boolean) // handy!
</code></pre>
<p>Together with <code>Number</code> – which converts all values into their <code>number</code> counterpart or <code>NaN</code>, this<br>
is a really cool way of getting to actual values quickly:</p>
<pre><code class="language-javascript">const x = [&quot;1.23&quot;, 2137123, &quot;wut&quot;, false, &quot;lol&quot;, undefined, null]
  .map(Number)
  .filter(Boolean) // [1.23, 2137123] 👍
</code></pre>
<p><code>Boolean</code> exists as a constructor and has the same conversion rules as the <code>Boolean</code> function.<br>
However, with <code>new Boolean(...)</code> you create a wrapping object, making value comparisions truthy,<br>
but reference comparisions falsy:</p>
<pre><code class="language-javascript">const value = Boolean(&quot;Stefan&quot;) // true
const reference = new Boolean(&quot;Stefan&quot;) // [Boolean: true]

value == reference // true
value === reference // false
</code></pre>
<p>You get to the value via <code>.valueOf()</code>:</p>
<pre><code class="language-javascript">value === reference.valueOf() // true
</code></pre>
<p>I have a <a href="https://repl.it/repls/ShamelessDelectableLint">REPL</a> for you to check.<br>
The use of <code>Boolean</code> as a function is obviously great, but <code>new Boolean</code> has very limited use.<br>
If you know a practical use case, please <a href="https://twitter.com/ddprrt">let me know</a>.</p>
<h2>Boolean in TypeScript</h2>
<p><code>boolean</code> in TypeScript is a primitive type. Be sure to use the lower case version and don’t<br>
refer to object instances from <code>Boolean</code></p>
<pre><code class="language-javascript">const boolLiteral: boolean = false // 👍
const boolObject: Boolean = false // 👎
</code></pre>
<p>It works, but it’s bad practice as we really rarely need <code>new Boolean</code> objects.</p>
<p>You can assign <code>true</code>, <code>false</code> and <code>undefined</code> and <code>null</code> to <code>boolean</code> in TypeScript<br>
without strict null checks.</p>
<pre><code class="language-javascript">const boolTrue: boolean = true // 👍
const boolFalse: boolean = false // 👍
const boolUndefined: boolean = undefined // 👍
const boolNull: boolean = null // 👍
</code></pre>
<p>With that, <code>boolean</code> is the only one we can express fully through union types:</p>
<pre><code class="language-javascript">type MyBoolean = true | false | null | undefined // same as boolean

const mybool: MyBoolean = true
const yourbool: boolean = false
</code></pre>
<p>When we enable the <code>strictNullChecks</code> compiler flag, the set of values reduces to <code>true</code> and <code>false</code>.</p>
<pre><code class="language-javascript">const boolTrue: boolean = true // 👍
const boolFalse: boolean = false // 👍
const boolUndefined: boolean = undefined // 💥
const boolNull: boolean = null // 💥
</code></pre>
<p>So our set reduces to two values in total.</p>
<pre><code class="language-javascript">type MyStrictBoolean = true | false
</code></pre>
<p>We can also get rid of null values with the NonNullable helper type:</p>
<pre><code class="language-javascript">type NonNullable&lt;T&gt; = T extends null | undefined
  ? never
  : T;

type MyStrictBoolean = NonNullable&lt;MyBoolean&gt; // true | false
</code></pre>
<p>The fact that <code>boolean</code> consists of a limited set of values only used in conditions,<br>
allows for interesting conditional types.</p>
<p>Think of an mutation in a datastore through a function. You set a flag in a function that<br>
updates e.g. the user id. You have to provide the user ID then:</p>
<pre><code class="language-javascript">type CheckUserId&lt;Properties, AddUserId&gt; = 
    AddUserId extends true 
    ? Properties &amp; { userId: string }
    : Properties &amp; { userId?: string }
</code></pre>
<p>Depending on the value of our generic <code>AddUserId</code>, we expect the property <code>userId</code> to be set or to be<br>
optional.</p>
<p>We can make this type more explicit by extending our generics from the types we expect</p>
<pre><code class="language-diff">- type CheckUserId&lt;Properties, AddUserId&gt; = 
+ type CheckuserId&lt;
+  Properties extends {},
+  AddUserId extends boolean
+ &gt;
     AddUserId extends true 
     ? Properties &amp; { userId: string }
     : Properties &amp; { userId?: string }
</code></pre>
<p>In use, it might declare a function like this:</p>
<pre><code class="language-javascript">declare function mutate&lt;P, A extends boolean = false&gt;
  (props: CheckUserId&lt;P, A&gt;, addUserId?: A): void
</code></pre>
<p>Note that I even set a default value for <code>A</code> to make sure <code>CheckUserId</code> gives the correct<br>
info depending on <code>addUserId</code> to be set or not.</p>
<p>The function in action:</p>
<pre><code class="language-javascript">mutate({}) // 👍
mutate({ data: 'Hello folks' }) // 👍
mutate({ name: 'Stefan' }, false) // 👍
mutate({ name: 'Stefan' }, true) // 💥 userId is missing
mutate({ name: 'Stefan', userId: 'asdf' }, true) // 👍 userId is here
</code></pre>
<p>Handy if your code relies a lot on truthy and falsy values.<br>
As always, there’s <a href="https://www.typescriptlang.org/play/index.html#code/C4TwDgpgBAwgFhAxgawKoGcICcCSATAHgAUsB7SLYASwnQBooBBPPDbfAPigF4oAoKIKYs2uPFAgAPYBAB2edFGBYArtAFCA-FBLls1WlABkUAN5QVmMQC4o6ZVVkBzKAF8Ng27ooHFJ85bseJq29liOLu58eEgANgCGWNAAZiqyiNSkslAAtirA8TIEHjpkPjSKUjLyiqauDCXMrFb4EtJyClAARqSksRDx2bzJ8bGYHAAUYGXotvBIaC2E3voVDE2inAzxIkshws1BAJS2AG6kVHh813kFMhN1R3y3hRAPUHiF8bYA5AASEFisVIUGSfWQ6B+bieL3u5lk8RyEF+AGUZCNZFD6qDRpgYflXu8EUjUejBliGMo1Pi7m94YjkVAfmiIBifgxAjYmfF0HhkhSlKoIEcgA">playground</a> for you.</p>
<p>//include helper/include-by-tag.html tag=“TypeScript” title=“More articles about TypeScript”</p>

</body>
</html>
