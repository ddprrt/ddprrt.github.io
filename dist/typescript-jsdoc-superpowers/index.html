<!doctype html>
<html>
<head>
</head>
<body>
    <p>One way to think about TypeScript is as a thin layer around JavaScript that adds type annotations.<br>
Type annotations that make sure you don‚Äôt make any mistakes. The TypeScript team worked hard on making<br>
sure that type checking also works with regular JavaScript files. TypeScript‚Äôs compiler (<code>tsc</code>) as well as language support in editors like VSCode give you a great developer experience without any compilation step. Let‚Äôs see how.</p>
<h2>Table of contents</h2>
<ul>
<li><a href="#typescript-with-jsdoc-annotations">TypeScript with JSDoc Annotations</a></li>
<li><a href="#activating-reports">Activating reports</a></li>
<li><a href="#inline-types">Inline types</a></li>
<li><a href="#defining-objects">Defining objects</a></li>
<li><a href="#defining-functions">Defining functions</a></li>
<li><a href="#importing-types">Importing types</a></li>
<li><a href="#working-with-generics">Working with generics</a></li>
<li><a href="#enums">Enums</a></li>
<li><a href="#typeof">typeof</a></li>
<li><a href="#extending-and-augmenting-from-classes">extending and augmenting from classes</a></li>
</ul>
<h2>TypeScript with JSDoc Annotations</h2>
<p>In the best case, TypeScript finds out types on its own by infering correctly from<br>
the way you use JavaScript.<br>
</p>
<pre><code class="language-javascript">function addVAT(price, vat) {
  return price * (1 + vat) // Oh! You add and mulitply with numbers, so it's a number
}
</code></pre>
<p>In the example above, we mulitply values. This operation is only valid for type <code>number</code>. With this information,<br>
TypeScript knows that the return value of <code>addVAT</code> will be of type <code>number</code>.</p>
<p>To make sure the input values are correct, we can add default values:</p>
<pre><code class="language-javascript">function addVAT(price, vat = 0.2) { // great, `vat`is also number!
  return price * (1 + vat)
}
</code></pre>
<p>But type inference just can get so far. We can provide more information for TypeScript by adding JSDoc comments:</p>
<pre><code class="language-javascript">/**
 * Adds VAT to a price
 * 
 * @param {number} price The price without VAT
 * @param {number} vat The VAT [0-1]
 * 
 * @returns {number}
 */
function addVAT(price, vat = 0.2) {
  return price * (1 + vat)
}
</code></pre>
<p>Paul Lewis has a great <a href="https://www.youtube.com/watch?v=YHvqbeh_n9U">video</a> on that. But there‚Äôs a lot, lot more<br>
to it than a couple of basic types in comments. Turns out working with JSDoc type gets you very far.</p>
<h2>Activating reports</h2>
<p>To make sure you not only provide type information, but get actual error feedback in your editor (or via <code>tsc</code>), please<br>
activate the <code>@ts-check</code> flag in your source files:</p>
<pre><code class="language-javascript">// @ts-check
</code></pre>
<p>If there‚Äôs one particular line that errors, but you think you know better, add the <code>@ts-ignore</code> flag:</p>
<pre><code class="language-javascript">// @ts-ignore
addVAT('1200', 0.1); // would error otherwise
</code></pre>
<h2>Inline types</h2>
<p>Defining parameters is one thing. Sometimes you want to make sure that a variable, which hasn‚Äôt been assigned<br>
yet, has the correct type. TypeScript supports inline comment annotations.</p>
<pre><code class="language-javascript">/** @type {number} */
let amount;
amount = '12'; // üí• does not work
</code></pre>
<p>Don‚Äôt forget the correct comment syntax. Inline comments with <code>//</code> won‚Äôt work.</p>
<h2>Defining objects</h2>
<p>Basic types is one thing, but in JavaScript you usually deal with complex types and objects.<br>
No problem for comment based type annotations:</p>
<pre><code class="language-javascript">/**
 * @param {[{ price: number, vat: number, title: string, sold?: boolean }]} articles
 */
function totalAmount(articles) {
  return articles.reduce((total, article) =&gt; {
    return total + addVAT(article)
  }, 0)
}
</code></pre>
<p>See that we defined a complex object type (just like we would do in TypeScript) inline as<br>
a parameter.</p>
<p>Annotating everything inline can become crowded very quickly. There‚Äôs a more elegant way of defining<br>
object types through <code>@typedef</code>:</p>
<pre><code class="language-javascript">/**
 * @typedef {Object} Article
 * @property {number} price
 * @property {number} vat
 * @property {string} string
 * @property {boolean=} sold
 */

/**
 * Now we can use Article as a proper type
 * @param {[Article]} articles
 */
function totalAmount(articles) {
  return articles.reduce((total, article) =&gt; {
    return total + addVAT(article)
  }, 0)
}
</code></pre>
<p>More work writing, but ultimately more readable. Also TypeScript now can identify <code>Article</code> with the name<br>
<code>Article</code>, providing better information in your IDE.</p>
<p>Please note the optional parameter <code>sold</code>. It‚Äôs defined with <code>@property {boolean=} sold</code>. An alternative<br>
syntax is <code>@property {boolean} [sold]</code>. Same goes for function <code>@params</code>.</p>
<h2>Defining functions</h2>
<p>Functions can be defined inline, just like their object counterparts:</p>
<pre><code class="language-javascript">/**
 * @param {string} url
 * @param {(status: number, response?: string) =&gt; void} cb
 */
function loadData(url, cb) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url)
  xhr.onload = () =&gt; {
    cb(xhr.status, xhr.responseText)
  }
}
</code></pre>
<p>Again, this can get very confusing quickly. There‚Äôs the <code>@callback</code> annotation that helps with that:</p>
<pre><code class="language-javascript">/**
 * @callback LoadingCallback
 * @param {number} status
 * @param {string=} response
 * @returns {void}
 */

/**
 * @param {string} url
 * @param {LoadingCallback} cb
 */
function loadData(url, cb) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url)
  xhr.onload = () =&gt; {
    cb(xhr.status, xhr.responseText)
  }
}
</code></pre>
<p><code>@callback</code> takes the same parameters as function annotation, but works like <code>@typedef</code></p>
<h2>Importing types</h2>
<p><code>@typedef</code> allows you to import types from any other <code>.js</code> or <code>.ts</code> file. With that you<br>
can write TypeScript type definitions in TypeScript and import them in your source files.</p>
<p>See <code>article.ts</code>:</p>
<pre><code class="language-javascript">export type Article = {
  title: string,
  price: number,
  vat: number,
  sold?: boolean,
}
</code></pre>
<p>And our <code>main.js</code>:</p>
<pre><code class="language-javascript">// The following line imports the Article type from article.ts and makes it
// available under Article
/** @typedef { import('./article').Article } Article */

/** @type {Article} */
const article = {
  title: 'The best book in the world',
  price: 10,
  vat: 0.2
}
</code></pre>
<p>You can also import a type directly in the type annotation:</p>
<pre><code class="language-javascript">/** @type {import('./article').Article} */
const article = {
  title: 'The best book in the world',
  price: 10,
  vat: 0.2
}
</code></pre>
<p>Great when working a mix of TypeScript where you don‚Äôt have ambient type definitions.</p>
<h2>Working with generics</h2>
<p>TypeScript‚Äôs generics syntax is available wherever there‚Äôs a type that can be generic:</p>
<pre><code class="language-javascript">/** @type PromiseLike&lt;string&gt; */
let promise;

// checks. `then` is available, and x is a string
promise.then(x =&gt; x.toUpperCase())
</code></pre>
<p>But you can define more elaborate generics (esp. functions with generics) with the <code>@template</code><br>
annotation:</p>
<pre><code class="language-javascript">/**
 * @template T
 * @param {T} obj
 * @param {(keyof T)[]} params
 */
function pluck(obj, ...params) {
  return params.map(el =&gt; obj[el])
}
</code></pre>
<p>Convenient, but a bit hard to do for complex generics. Inline generics still work the TypeScript way:</p>
<pre><code class="language-javascript">/** @type { &lt;T, K extends keyof T&gt;(obj: T, params: K[]) =&gt; Array&lt;T[K]&gt;} */
function values(obj, ...params) {
  return params.map(el =&gt; obj[el])
}

const numbers = values(article, 'price', 'vat')
const strings = values(article, 'title')
const mixed = values(article, 'title', 'vat')
</code></pre>
<p>Have even more complex generics? Consider putting them in a TypeScript file and import it via <a href="#importing-types">the import function</a>.</p>
<h2>Enums</h2>
<p>Turn a specially structured JavaScript object into an enum and make sure values are consistent:</p>
<pre><code class="language-javascript">/** @enum {number} */
const HTTPStatusCodes = {
  ok: 200,
  forbidden: 403,
  notFound: 404,
}
</code></pre>
<p>Enums differ greatly from regular TypeScript enums. They make sure that every key in this object has the specified<br>
type.</p>
<pre><code class="language-javascript">/** @enum {number} */
const HTTPStatusCodes = {
  ok: 200,
  forbidden: 403,
  notFound: 404,
  errorsWhenChecked: 'me' // üí£
}
</code></pre>
<p>That‚Äôs all they do.</p>
<h2>typeof</h2>
<p>One of my most favourite tools, <code>typeof</code> is also available. Saves you a ton of editing:</p>
<pre><code class="language-javascript">/**
 * @param {number} status The status code as a number
 * @param {string} data The data to work with
 */
function defaultCallback(status, data) {
  if(status === 200) {
    document.body.innerHTML = data
  }
}

/**
 * @param {string} url the URL to load data from
 * @param {typeof defaultCallback} cb what to do afterwards
 */
function loadData(url, cb) {
  const xhr = new XMLHttpRequest();
  xhr.open('GET', url)
  xhr.onload = () =&gt; {
    cb(xhr.status, xhr.responseText)
  }
}
</code></pre>
<h2>extending and augmenting from classes</h2>
<p>The <code>extends</code> annotation allow you to specify generic parameters when extending from a basic<br>
JavaScript class. See the example below:</p>
<pre><code class="language-javascript">/**
 * @template T
 * @extends {Set&lt;T&gt;}
 */
class SortableSet extends Set {
  // ...
}
</code></pre>
<p><code>@augments</code> on the other hand allows you to be a lot more specific with generic parameters:</p>
<pre><code class="language-javascript">/**
 * @augments {Set&lt;string&gt;}
 */
class StringSet extends Set {
  // ...
}
</code></pre>
<p>Handy!</p>
<h2>Bottom line</h2>
<p>TypeScript annotations in plain JavaScript go really far. There‚Äôs a little more to TypeScript especially when<br>
entering generics, but for a lot of basic tasks you get a lot of editor superpowers without installing any<br>
compiler at all.</p>
<p>Know more? Shoot me a <a href="https://twitter.com/ddprrt">tweet</a>. I‚Äôm more than happy to add them here.</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
