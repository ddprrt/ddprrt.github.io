<!doctype html>
<html>
<head>
</head>
<body>
    <p>Factory functions are a popular tool in JavaScript to create a diversity of objects with a single call.<br>
There‚Äôs a particular factory function that you might have used at some point:</p>
<pre><code class="language-javascript">document.createElement('video') // creates an HTMLVideoElement
</code></pre>
<p><code>document.createElement</code> takes any string and creates <code>HTMLElement</code> instances. <code>HTMLElement</code> is one<br>
of the most derived objects in the DOM. Every available tag creates it‚Äôs on<br>
derivate. For example <code>document.createElement('video')</code> creates an instance of <code>HTMLVideoElement</code>.</p>
<p>But how do we type a factory function like that? One that has a couple of dozen different return types? Let‚Äôs try.</p>
<p><strong>NOTE: TypeScript with the <code>dom</code> library activated in <code>tsconfig.json</code> knows of all <code>HTMLElement</code> derivates</strong>.</p>
<h2>With conditional types</h2>
<p>The original typings for <code>document.createElement</code> take a string as parameter,<br>
and returns an object of type <code>HTMLElement</code>:</p>
<pre><code class="language-javascript">declare function createElement(tag: string, options?: any): HTMLElement
</code></pre>
<p>This is true, but not specific enough. We can be a lot more specific, since we know which tags implement corresponding<br>
<code>HTMLElement</code> derivates.</p>
<p>The first thing that came into my mind were conditional types. They were made for use cases like that!<br>
We know that <code>tag</code> is a subset of string, and more important: we know exactly which subset! The collection of<br>
tags available in your browser.</p>
<p>A possible generic type for the <code>createElement</code> factory function could look like this:</p>
<pre><code class="language-javascript">type CreatedElement&lt;T extends string&gt; =    /** 1 **/
  T extends 'a' ? HTMLAnchorElement :      /** 2 **/
  T extends 'div' ? HTMLDivElement :
  T extends 'video' ? HTMLVideoElement :
  HTMLElement;                             /** 3 **/
</code></pre>
<p>Let‚Äôs go over this definition in detail:</p>
<ol>
<li>We start with a generic type <code>CreatedElement&lt;T&gt;</code>. The generic placeholder <code>T</code> has to be a subset of string</li>
<li>We then test for a specific <strong>unit</strong> type from the <code>string</code> subset. For example, the string <code>&quot;a&quot;</code> is of type <code>string</code>,<br>
but also of type <code>&quot;a&quot;</code>. You can think of <code>string</code> as the universe of all possible string unit types. If our generic<br>
placeholder <code>T</code> extends this particular subset of <code>&quot;a&quot;</code>, we know that the result has to be of type <code>HTMLAnchorElement</code>.<br>
The <em>else</em> branch starts a cascade through all known HTML tags. In our example, we know of <code>div</code> and <code>video</code>.</li>
<li>At the end of this cascade, when we went through all known HTML tags, we return the generic <code>HTMLElement</code> as a fallback.<br>
This is totally in tune with the way <code>createElement</code> works. When you create an element with a tag the browser doesn‚Äôt know,<br>
you get at least an <code>HTMLElement</code>.</li>
</ol>
<p>So far, so good. This even looks like a map from string to HTMLElement derivate. Now the only thing we have to do is<br>
to extend this list with all available tags and return the respective element instance. We can even use things like union types to<br>
help with types that implement more than one tag:</p>
<pre><code class="language-javascript">type CreatedElement&lt;T extends string&gt; = 
  T extends 'a' ? HTMLAnchorElement :  
  T extends 'div' ? HTMLDivElement :
  T extends 'video' ? HTMLVideoElement :
  T extends 'thead' | 'tfoot' | 'tbody' ? HTMLTableSectionElement : /** 1 **/
  HTMLElement; 
</code></pre>
<ol>
<li>All three of <code>thead</code>, <code>tbody</code> and <code>tfoot</code> implement <code>HTMLTableSectionElement</code>. We can use a union type of all three unit types<br>
to identify <code>HTMLTableSectionElement</code></li>
</ol>
<p>The solution is good and robust, but has one catch. A rather big one. The amount of comparisions is finite. Even though this looks like<br>
a map of types, in reality it‚Äôs a nested comparision chain:</p>
<pre><code class="language-javascript">type CreatedElement&lt;T extends string&gt; = 
  T extends 'a' ? HTMLAnchorElement :  
    T extends 'div' ? HTMLDivElement :
      T extends 'video' ? HTMLVideoElement :
        T extends 'thead' | 'tfoot' | 'tbody' ? HTMLTableSectionElement :
          HTMLElement; 
</code></pre>
<p>So it‚Äôs nested. This also means that with every further comparision, there has to be reference to the original<br>
comparison. Internally, this can be best done via a recursion. And recursions take up memory.</p>
<p>This is why TypeScript gives you a hard limit of <strong>50 nested comparisons</strong> to make sure memory and performance<br>
goals are met. If you extend your list beyond 50 comparisions, you get the error<br>
<strong>&quot;Type instantiation is excessively deep and possibly infinite&quot;</strong>. Check out the issue <a href="https://github.com/microsoft/TypeScript/issues/28663">#28663</a> on<br>
Github.</p>
<p>So that doesn‚Äôt solve our problem in the long run. So what shall we do?</p>
<h2>Mapped types</h2>
<p>To find a proper solution for that problem, let‚Äôs think for one moment how you would‚Äôve implemented the<br>
<code>document.createElement</code> factory function yourself in JavaScript.<br>
I would have used an object, where each key corresponds to the correct implementation.<br>
And I would‚Äôve indexed the object dynamically with an index access. Something like that:</p>
<p><strong>NOTE: This does not work. This is just for demonstration purposes</strong></p>
<pre><code class="language-javascript">const elementMap = {
  a: HTMLAnchorElement,
  div: HTMLDivElement,
  video: HTMLVideoElement
}

function createElement(tag) {
  return tag in elementMap ? new elementMap[tag]()
    : new HTMLElement()
}
</code></pre>
<p>This obviously doesn‚Äôt work, that‚Äôs what the <code>document.createElement</code> factory function is for. But it illustrates<br>
the way of accessing via the index access operator rather nice. Since every key in an object can be accessed using a<br>
string, we select the right constructor out of this list, and create a new instance. If we don‚Äôt have a constructor,<br>
let‚Äôs create a generic <code>HTMLElement</code>.</p>
<p>In TypeScript, we can create types that work in a similar manner. First, let‚Äôs create the <code>AllElements</code> type which is<br>
a map of all tags to their corresponding <code>HTMLElement</code> derivate:</p>
<pre><code class="language-javascript">type AllElements = {
  'a': HTMLAnchorElement,
  'div': HTMLDivElement,
  'video': HTMLVideoElement,
  ... //extend as you need
}
</code></pre>
<p>This is what I like to call a <strong>type map</strong>. We <em>could</em> use this type to create an object of type <code>AllElements</code>,<br>
but in reality we most likely won‚Äôt need that. We only use this type as an helper type for <code>CreatedElement</code>:</p>
<pre><code class="language-javascript">type CreatedElement&lt;T extends string&gt; = 
  T extends keyof AllElements ? AllElements[T] : /** 1 **/
  HTMLElement;                                   /** 2 **/
</code></pre>
<ol>
<li>The type signatur is the same as in the previous example. The generic placeholder <code>T</code> extends from <code>string</code>.<br>
But now we check if <code>T</code> is somewhere in the keys of <code>AllElements</code>. If so, we index the type that is stored<br>
with this particular key <code>T</code>. That‚Äôs how we get the correct derivate!</li>
<li>In all other cases, we have ‚Äújust‚Äù an <code>HTMLElement</code>.</li>
</ol>
<p>Do you see how similar this type definition is to the JavaScript example above? Of course the way I wrote<br>
JavaScript earlier is just one way to express myself, and I used it deliberately to show the similarities<br>
with conditional types. But it shows how close TypeScript tries to be to JavaScript in terms of syntax and<br>
semantics.</p>
<p>The cool thing is: We are just moving in type space. No source created, just information to make your<br>
code a lot safer. Like that:</p>
<pre><code class="language-javascript">declare function createElement&lt;T extends string&gt;(tag: T, options?: any): CreatedElement&lt;T&gt;
</code></pre>
<p>We can use the function like that:</p>
<pre><code class="language-javascript">createElement('video') // It's an HTMLVideoElement
createElement('video').src = '' // `src` exists
createElement('a').href = '' // It's an HTMLAnchorElement with an `href`
</code></pre>
<p>We can even write our own factory functions, that can do a little more that <em>just</em> creating elements:</p>
<pre><code class="language-javascript">function elementFactory&lt;T extends string&gt;(tag: T, 
  defaultProps: Partial&lt;CreatedElement&lt;T&gt;&gt;) : CreatedElement&lt;T&gt; {

  const element = createElement(tag);
  return Object.assign(element, defaultProps)
}
</code></pre>
<p>This factory takes a couple of default properties that need to be available in the<br>
generated output element. So things like:</p>
<pre><code class="language-javascript">elementFactory('video', { src: '' });
</code></pre>
<p>Can even be autocompleted. And TypeScript warns you if you want to specify a property<br>
that does not exist:</p>
<pre><code class="language-javascript">elementFactory('video', { source: '' }) // üí• Error: this property does not exist
</code></pre>
<p>Pretty sweet, huh?</p>
<h2>Bottom line</h2>
<p>Type maps are a good tool for factory functions which produce a ton of different results. And most likely<br>
for a lot, lot more. If you want to expand on the example shown above, take this <a href="https://gist.github.com/ddprrt/61644bdbbb48e577ca54fdb2ee16ed56">gist</a>. And look at <a href="https://www.typescriptlang.org/play/index.html?ssl=85&amp;ssc=2&amp;pln=80&amp;pc=1#code/C4TwDgpgBAggNnAonCBbCA7YBnKBeKKAbwFgAoQgcgENKAuKACQBUBZAGRgwGMALAewBOyNJmABuclQAmASwBu9Jm3YARBSPRZJFKJWxhqGJSw4BlQxk1idVAK5wTKgKrtZ2YNe1Qpe4LOAUJw5mAJQvCV9KYAgAD2BqQQhaBlN2ZjjgGCTqCNs-NDA4ahjg9MLimLyo4AAzfn5gMuZqACMUMwhuf34rFC1I3WjeZOlmto6unr7RbRrW-mkQcfaITu7ZXuqh4EEVlAAlfgB3baoE1f2IM71ufkdUlRbVgGF7m8o7uABzQX47MBXN5Ifo2Gq8K6MUYQQQvCAID7AMaPEITCCqErUOEI0FzIbcahgaZAwnTD4eEBBFHsMygcK4wZUbDwqZlToobrk7iCWREtnc3meBn5SjtfjcADWAEc7I0IGUAIqyqrCqJSxXK66qoZgP6-CDYbBlAAKeqSho+uvl1NNWtmjL0hkE1FQJsSLstbudv0JvA+-2AYDsTWpAHlg0GhfaRfwiZtjGG41ttVRY8Bfv9AYngABxP4A-2tABWrLDxam-oeyg4obcHg+sgwRuprEWH2k8LKrekH3QMT2LYg-d7Q5S1fYrFHvcSMog1vHrBndjn06zC8JH3ksg7-DKADVtxB+B9qHY5LvqTAz5sPnBGxKym4MBLbxBvphkeP2G+P7e2p3qXYf8QWjKI70fABJBsMEjMoIJg4MG1Qb44NQah3wbWpnXQOCADFsLtAYRV4YBUCrNJGFIkCiKiXgAEYyihag5Awb4Pl4AAmRjRkbNiUz0XgAGZuOY3j2IAFhEli+NAoZeAAViksT+MoXgADYlNY9jRik9iB3HRgDg+LCXQNIcynw0zOijGihhMnDqUs9BjKEV1HNclysAs3obLBOzZHhaRmRDcdcICuBpGsj40FaCBPzSRBUFinsVOkTE7w8MoMQSOtfLxGRyJUVRco+AkMHkahm3HF4jAq7APlaYNgF6MoACEmuTWSqAWJY2sWEAGsq+c0laoaGv0kajJUxJkjKbJkgicgAF9yHIUBICgF4chiaQEoZAAeZgoEyD9cAlCAQH4WpYBxe1sAAPnwG7qLEbAAG1mAAXR0NbwGgLbkh2iJDuO+JTqgDweVYx68F8I6TowIKoHOy7rvgF6sFwAB+Tbtrivb7UOx7qW2cgO24YokigWo7B4aYoG5QHCLEEGEaRyHePugAKBJvgYZgABooDTeNsCxhgjBAABKBgAZKOLgeYe7VrIGm6fjY6GVw6huiEEBWbBxHcA56GefQ-mhd8DtalPOBgFNWNsAYY1En8ag4H2uWgYOpX7qlqBZbxlLCaV4gVcIO4m2ATX7Sexn5YiM3vil-IkmAOxBAwKBQ3LboADpKuwWRvgwLmWQGIXrdt+2-jAbApeWlXy7EbXdcEEAucoLcd0oIWiAhwRuAYShKCgJaU-IZusFb5r2877uj174gIf+QeIGH0fx6gAB6beoEAXg3AFKdqBEEEP5BAYYBeHcKBdVjGFQCgaR+ANKAMEaUH3GAcggA">this playground</a> to play around.</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
