<!doctype html>
<html>
<head>
</head>
<body>
    <p>In JavaScript, you can define object properties on the fly with <code>Object.defineProperty</code>. This is useful if you want your properties to be read-only or similar. Think of a storage object that has a maximum value that shouldn‚Äôt be overwritten:</p>
<pre><code class="language-javascript">const storage = {
  currentValue: 0
}

Object.defineProperty(storage, 'maxValue', {
  value: 9001,
  writable: false
})

console.log(storage.maxValue) // 9001

storage.maxValue = 2

console.log(storage.maxValue) // still 9001
</code></pre>
<p><code>defineProperty</code> and property descriptors are very complex. They allow you to do everything with properties that usually is reserved for built-in objects. So they‚Äôre common in larger codebases. TypeScript ‚Äì <em>at the time of this writing</em> ‚Äì has a little problem with <code>defineProperty</code>:</p>
<pre><code class="language-javascript">const storage = {
  currentValue: 0
}

Object.defineProperty(storage, 'maxValue', {
  value: 9001,
  writable: false
})

// üí• Property 'maxValue' does not exist on type...
console.log(storage.maxValue) 
</code></pre>
<p>If we don‚Äôt explicitly typecast, we don‚Äôt get <code>maxValue</code> attached to the type of <code>storage</code>. However, for simple use cases, we can help!</p>
<h2>assertion signatures</h2>
<p>With TypeScript 3.7, the team introduced assertion signatures. Think of an <code>assertIsNumber</code> function where you can make sure some value is of type <code>number</code>. Otherwise, it throws an error. This is similar to the <code>assert</code> function in Node.js:</p>
<pre><code class="language-javascript">function assertIsNumber(val: any) {
  if (typeof val !== &quot;number&quot;) {
    throw new AssertionError(&quot;Not a number!&quot;);
  }
}

function multiply(x, y) {
  assertIsNumber(x);
  assertIsNumber(y);
  // at this point I'm sure x and y are numbers
  // if one assert condition is not true, this position
  // is never reached
  return x * y;
}
</code></pre>
<p>To comply with behavior like this, we can add an assertion signature that tells TypeScript that we know more about the type after this function:</p>
<pre><code class="language-diff">- function assertIsNumber(val: any) {
+ function assertIsNumber(val: any) : asserts val is number
    if (typeof val !== &quot;number&quot;) {
      throw new AssertionError(&quot;Not a number!&quot;);
    }
  }
</code></pre>
<p>This works a lot like <a href="/typescript-type-predicates/">type predicates</a>, but without the control flow of a condition-based structure like <code>if</code> or <code>switch</code>.</p>
<pre><code class="language-javascript">function multiply(x, y) {
  assertIsNumber(x);
  assertIsNumber(y);
  // Now also TypeScript knows that both x and y are numbers
  return x * y;
}
</code></pre>
<p>If you look at it closely, you can see those assertion signatures can <strong>change the type of a parameter or variable on the fly</strong>.<br>
This is just what <code>Object.defineProperty</code> does as well.</p>
<h2>custom defineProperty</h2>
<blockquote>
<p><strong>Disclaimer</strong>: The following helper does not aim to be 100% accurate or complete. It might have errors, it might not tackle every edge case of the <code>defineProperty</code> specification. It might, however, handle a lot of use cases well enough. So use it at your own risk!</p>
</blockquote>
<p>Just as with <a href="/typescript-hasownproperty/">hasOwnProperty</a>, we create a helper function that mimics the original function signature:</p>
<pre><code class="language-javascript">function defineProperty&lt;
  Obj extends object,
  Key extends PropertyKey,
  PDesc extends PropertyDescriptor&gt;
  (obj: Obj, prop: Key, val: PDesc) {
  Object.defineProperty(obj, prop, val);
}
</code></pre>
<p>We work with 3 generics:</p>
<ol>
<li>The object we want to modify, of type <code>Obj</code>, which is a subtype of <code>object</code></li>
<li>Type <code>Key</code>, which is a subtype of <code>PropertyKey</code> (built-in), so <code>string | number | symbol</code>.</li>
<li><code>PDesc</code>, a subtype of <code>PropertyDescriptor</code> (built-in). This allows us to define the property with all its features (writability, enumerability, reconfigurability).</li>
</ol>
<p>We use generics because TypeScript can narrow them down to a very specific unit type. <code>PropertyKey</code> for example is all numbers, strings, and symbols. But if I use <code>Key extends PropertyKey</code>, I can pinpoint <code>prop</code> to be of e.g. type <code>&quot;maxValue&quot;</code>. This is helpful if we want to change the original type by adding more properties.</p>
<p>The <code>Object.defineProperty</code> function either changes the object or throws an error should something go wrong. Exactly what an assertion function does. Our custom helper <code>defineProperty</code> thus does the same.</p>
<p>Let‚Äôs add an assertion signature. Once <code>defineProperty</code> successfully executes, our object has another property. We are creating some helper types for that. The signature first:</p>
<pre><code class="language-diff">function defineProperty&lt;
  Obj extends object,
  Key extends PropertyKey,
  PDesc extends PropertyDescriptor&gt;
-  (obj: Obj, prop: Key, val: PDesc) {
+  (obj: Obj, prop: Key, val: PDesc): asserts obj is Obj &amp; DefineProperty&lt;Key, PDesc&gt; {
  Object.defineProperty(obj, prop, val);
}
</code></pre>
<p><code>obj</code> then is of type <code>Obj</code> (narrowed down through a generic), and our newly defined property.</p>
<p>This is the <code>DefineProperty</code> helper type:</p>
<pre><code class="language-javascript">type DefineProperty&lt;Prop extends PropertyKey, Desc extends PropertyDescriptor&gt; = 
  Desc extends { writable: any, set(val: any): any } ? never :
  Desc extends { writable: any, get(): any } ? never :
  Desc extends { writable: false } ? Readonly&lt;InferValue&lt;Prop, Desc&gt;&gt; :
  Desc extends { writable: true } ? InferValue&lt;Prop, Desc&gt; :
  Readonly&lt;InferValue&lt;Prop, Desc&gt;&gt;
</code></pre>
<p>First, we deal with the <code>writeable</code> property of a <code>PropertyDescriptor</code>. It‚Äôs a set of conditions to define some edge cases and conditions of how the original property descriptors work:</p>
<ol>
<li>If we set <code>writable</code> and any property accessor (get, set), we fail. <code>never</code> tells us that an error was thrown.</li>
<li>If we set <code>writable</code> to <code>false</code>, the property is read-only. We defer to the <code>InferValue</code> helper type.</li>
<li>If we set <code>writable</code> to <code>true</code>, the property is not read-only. We defer as well</li>
<li>The last, default case is the same as <code>writeable: false</code>, so <code>Readonly&lt;InferValue&lt;Prop, Desc&gt;&gt;</code>. (<code>Readonly&lt;T&gt;</code> is built-in)</li>
</ol>
<p>This is the <code>InferValue</code> helper type, dealing with the set <code>value</code> property.</p>
<pre><code class="language-javascript">type InferValue&lt;Prop extends PropertyKey, Desc&gt; =
  Desc extends { get(): any, value: any } ? never :  
  Desc extends { value: infer T } ? Record&lt;Prop, T&gt; : 
  Desc extends { get(): infer T } ? Record&lt;Prop, T&gt; : never;
</code></pre>
<p>Again a set of conditions:</p>
<ol>
<li>Do we have a getter and a value set, <code>Object.defineProperty</code> throws an error, so never.</li>
<li>If we have set a value, let‚Äôs infer the type of this value and create an object with our defined property key, and the value type</li>
<li>Or we infer the type from the return type of a getter.</li>
<li>Anything else: We forgot. TypeScript won‚Äôt let us work with the object as it‚Äôs becoming <code>never</code></li>
</ol>
<h2>In action!</h2>
<p>Lots of helper types, but roughly 20 lines of code to get it right:</p>
<pre><code class="language-javascript">type InferValue&lt;Prop extends PropertyKey, Desc&gt; =
  Desc extends { get(): any, value: any } ? never :  
  Desc extends { value: infer T } ? Record&lt;Prop, T&gt; : 
  Desc extends { get(): infer T } ? Record&lt;Prop, T&gt; : never;

type DefineProperty&lt;Prop extends PropertyKey, Desc extends PropertyDescriptor&gt; = 
  Desc extends { writable: any, set(val: any): any } ? never :
  Desc extends { writable: any, get(): any } ? never :
  Desc extends { writable: false } ? Readonly&lt;InferValue&lt;Prop, Desc&gt;&gt; :
  Desc extends { writable: true } ? InferValue&lt;Prop, Desc&gt; :
  Readonly&lt;InferValue&lt;Prop, Desc&gt;&gt;

function defineProperty&lt;
  Obj extends object,
  Key extends PropertyKey,
  PDesc extends PropertyDescriptor&gt;
  (obj: Obj, prop: Key, val: PDesc): asserts obj is Obj &amp; DefineProperty&lt;Key, PDesc&gt; {
  Object.defineProperty(obj, prop, val)
}
</code></pre>
<p>Let‚Äôs see what TypeScript does:</p>
<pre><code class="language-javascript">
const storage = {
  currentValue: 0
}

defineProperty(storage, 'maxValue', { writable: false, value: 9001 })

storage.maxValue // it's a number
storage.maxValue = 2 // Error! It's read-only

const storageName = 'My Storage'
defineProperty(storage, 'name', {
  get() {
    return storageName
  }
})

storage.name // it's a string!

// it's not possible to assing a value and a getter
defineProperty(storage, 'broken', {
  get() {
    return storageName
  },
  value: 4000
})

// storage is never because we have a malicious property descriptor
storage 
</code></pre>
<p>As said, this most likely won‚Äôt deal with all edge cases, but it‚Äôs a good start. And if you know what you‚Äôre dealing with, you can get very far.</p>
<p>As always, <a href="https://www.typescriptlang.org/play/index.html?ssl=47&amp;ssc=76&amp;pln=20&amp;pc=1#code/C4TwDgpgBAkgdgMwgJwGoEMA2BXCAeABWQHswoIAPYCOAEwGcojSVQBpCEAGigBEJ6AYwB8UALwBYAFBQ+AweSo0GUAN5QA5hGAAKAJQAuKOjjcoANyy4jJkFAC+UAPxQ4EcyihGo02fyGK1HSM6pY4EEYAloieACoOzlAAShCCxMi0hCRgPLGiRr5yAZRBKupauoZQ0UjIUPGOLilpGVmkufmu7igA3NLSoJByCNEQzJDIoG1kJcqM46wgHGb+CrPBTNmLq8iRYMDpomI+MkVrShvqAO67wOgARpgRxqY89No6YTamVbYJLm4PHUDIVVoE5mooDdIndHs9bDwKvpvnZGl0gV5QfJwZcobcHk8jAgsO9-skIOhaMQ4JgQHh4LUMOFpjxVsJ8ljihcyniYQTnsBkLgyQyUEzcCyzhzTilKdTafSYmgrPhxqz5Oz+lIENg4IJgJFqVBaBARm4FpM6YUAPL3ABWOJUxHtqWAXEKy0d8y2luW7tOBDB6xUFtAOz2B2QwkKOmddqMtrtPDA2SMfosWCMgfkv3o70mjDj1UYiagADJhqNQ3T09mhKJVDaXfqAHQms1jH2gWP25PZHhhPTSexatJwejAKAT9LoLTiNSFQTYZDIGjAcXPAAMw617arXZAOmnyFnEB4AHIALboCgb888a74uFEklnjPhIwATk3m4AjA4hykaRj1PFtr1vFUoAAeig6pgHPRh0FcbBL3uFBgMjUDwI3ecACZoNggBRFd0gAQlgeDGFXSkAFp5RAUdqQnKdMK0AA5dBL2gY5zwAWTsABlViIHPaQ93NA8j2Ei84E4kSH0KJE9AXU5ZFXYBlzgFiZ3YuTChHKR7EAjCdIgFtZK4gi4IQ4wWN2OANFIrUYOsxg4GIScwGIPNIjhKADmMHyHNssJhRMWhbIqahkDE019xYS0pNMi97hIABrGh7xU2QlOy2QoHUzTtJPXSuP0-1ZFC54ABYf23QzjKkEC5xc5roEiNzujqNDBHQbBSSuaAAAt0A8Wzr0wSJBENfqoBTBLQGNeRdn2dJpCAA">there‚Äôs a playground for you to fiddle around</a>.</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
