<!doctype html>
<html>
<head>
</head>
<body>
    <p>Mapped types are great, as they allow for the flexibility in object structures JavaScript is known for.<br>
But they have some crucial implications on the type system. Take this example:</p>
<pre><code class="language-javascript">type Messages = 
  'CHANNEL_OPEN' | 'CHANNEL_CLOSE' | 'CHANNEL_FAIL' | 
  'MESSAGE_CHANNEL_OPEN' | 'MESSAGE_CHANNEL_CLOSE' | 'MESSAGE_CHANNEL_FAIL'

type ChannelDefinition = {
  [key: string]: {
    open: Messages,
    close: Messages,
    fail: Messages
  }
}
</code></pre>
<p>This is from a generic messaging library, that takes a ‚Äúchannel definition‚Äù where multiple<br>
channel tokens can be defined. The keys from this channel definition object are what the user<br>
wants it to be. So this is a valid channel definition:</p>
<pre><code class="language-javascript">const impl: ChannelDefinition = {
  test: {
    open: 'CHANNEL_OPEN',
    close: 'CHANNEL_CLOSE',
    fail: 'CHANNEL_FAIL'
  },
  message: {
    open: 'MESSAGE_CHANNEL_OPEN',
    close: 'MESSAGE_CHANNEL_CLOSE',
    fail: 'MESSAGE_CHANNEL_FAIL'
  }
} 
</code></pre>
<p>We have a problem when we want to access the keys we defined so flexibly. Let‚Äôs say we have<br>
a function that opens a channel. We pass the whole channel definition object, as well as the<br>
channel we want to open.</p>
<pre><code class="language-javascript">declare function openChannel(
  def: ChannelDefinition,
  channel: keyof ChannelDefinition
)
</code></pre>
<p>So what are the keys of <code>ChannelDefinition</code>? Well, it‚Äôs every key: <code>[key: string]</code>. So the<br>
moment we assign a specific type, TypeScript treats <code>impl</code> as this specific type, ignoring<br>
the actual implementation. The contract is fulfilled. Moving on. This allows for wrong keys to<br>
be passed:</p>
<pre><code class="language-javascript">openChannel(impl, 'massages') // Passes, even though &quot;massages&quot; is no part of impl
</code></pre>
<p>So we are more interested in the actualy implementation, not the type we assing to our constant.<br>
This means we have to get rid of the <code>ChannelDefinition</code> type and make sure we care about the<br>
actual type of the object.</p>
<p>First, the <code>openChannel</code> function should take any object that is a subtype of <code>ChannelDefinition</code>,<br>
but work with the concrete subtype:</p>
<pre><code class="language-diff">- declare function openChannel(
-   def: ChannelDefinition,
-   channel: keyof ChannelDefinition
- )
+ declare function openChannel&lt;T extends ChannelDefinition&gt;(
+   def: T,
+   channel: keyof T
+ )
</code></pre>
<p>TypeScript now works on two levels:</p>
<ol>
<li>Checking if <code>T</code> actually extends <code>ChannelDefinition</code>. If so, we work with type <code>T</code></li>
<li>All our function parameters are typed with the generic <code>T</code>. This also means we get<br>
the <em>real</em> keys of <code>T</code> through <code>keyof T</code>.</li>
</ol>
<p>To benefit from that, we have to get rid of the type definition for <code>impl</code>. The explicit<br>
type definition overrides all actual types. From the moment we explicitly specify the type,<br>
TypeScript treats it as <code>ChannelDefinition</code>, not the actual underlying subtype. We also have<br>
to set <code>const</code> context, so we can convert all strings to their unit type (and thus be compliant<br>
with <code>Messages</code>):</p>
<pre><code class="language-diff">- const impl: ChannelDefinition = { ... };
+ const impl: { ... }  as const;
</code></pre>
<p>Without <code>const</code> context, the inferred type of <code>impl</code>is:</p>
<pre><code class="language-javascript">/// typeof impl 
{
  test: {
    open: string;
    close: string;
    fail: string;
  };
  message: {
    open: string;
    close: string;
    fail: string;
  };
}
</code></pre>
<p>With <code>const</code> context, the actual type of <code>impl</code> is now:</p>
<pre><code class="language-javascript">/// typeof impl 
{
  test: {
    readonly open: &quot;CHANNEL_OPEN&quot;;
    readonly close: &quot;CHANNEL_CLOSE&quot;;
    readonly fail: &quot;CHANNEL_FAIL&quot;;
  };
  message: {
    readonly open: &quot;MESSAGE_CHANNEL_OPEN&quot;;
    readonly close: &quot;MESSAGE_CHANNEL_CLOSE&quot;;
    readonly fail: &quot;MESSAGE_CHANNEL_FAIL&quot;;
  };
}
</code></pre>
<p><code>const</code> context allows us to satisfy the contract made by<br>
<code>ChannelDefinition</code>. Now, <code>openChannel</code> correctly errors:</p>
<pre><code class="language-javascript">openChannel(impl, 'messages') // ‚úÖ satisfies contract
openChannel(impl, 'massages') // üí• bombs
</code></pre>
<p>You might be in a space where you need to work with the concrete type, that satisfies<br>
the <code>ChannelDefinition</code> contract, outside of a function. For that, we can mimic the same<br>
behaviour using the <code>Validate&lt;T, U&gt;</code> helper type:</p>
<pre><code class="language-javascript">type Validate&lt;T, U&gt; = T extends U ? T : never; 
</code></pre>
<p>Use this as follows:</p>
<pre><code class="language-javascript">const correctImpl = {
  test: { open: 'CHANNEL_OPEN', close: 'CHANNEL_CLOSE', fail: 'CHANNEL_FAIL' }
} as const;

const wrongImpl = {
  test: { open: 'OPEN_CHANNEL', close: 'CHANNEL_CLOSE', fail: 'CHANNEL_FAIL' }
} as const;


// ‚úÖ returns typeof correctImpl
type ValidatedCorrect 
  = Validate&lt;typeof correctImpl, ChannelDefinition&gt;;

// üí• returns never
type ValidatedWrong 
  = Validate&lt;typeof wrongImpl, ChannelDefinition&gt;;
</code></pre>
<p>As always, there‚Äôs a <a href="https://www.typescriptlang.org/play/index.html#code/C4TwDgpgBAshDO8CGBzBUC8UDkBhAEgIIByxAogDID6A8gApnHZQA+OBJ51uFNAymWZs8RUpSoAxQgEkKQqAFgAUFBwwyfPoQDiZKhzHV6jednWadeg1328Bp81t37RNqbOzLloSFFwALJAA7IIgAGwARCAAzAEsg2OBYgHsgzCgAb2VVAG0AawgQAC4oeGAAJ3iUAF0SrJVVKGTIIJK4RFQEABpsxoBjMOT4CDaEZDR4HobVaKRYsNGOid6AX2U1pWU+1LKoWIBbMDD0+tVgBGA63tVmiFb2V3FjJinGqAGhkYfOcR5+QVejVm8xKIh+1HcclWgP2Y06V2mTRaoMclhc4NoDBe13eg2GKI0Tisj24dgBOOBCzUhLR1nEkM8DQ2KygSHg7x2wAA3F4lAATCADJDlaDRACuQT6SVSSLuAWCoTCAAoBXEEtL7vKQuEomrEikgl13oFtVSCiBktE-CbFbr4vrUgBKEoAN2SsT5PM2SluQS1iqVByORuw5zKACZsI7eT5oAA1JBhD1Ic4AHmkRtwAD50tIoBAAB7nIJ89m4KAAfigeZKoRdEHKXMU3oFQpFUHFko1sr9NvCCaTfJTEFTABUsyqYvaNSUB8m06PM33IlP1Qas0a+suSubLVBR86oG6PV7lL7-f3E-OIIHDmEQ2HgJHoy3BWFhaKJVKDT2L2EyEWdx8mO+aASWZbLnaa6pBOqolIuxoKuEO6FHuB6uu6nq8uey4AcWfK3sGOCPs+QA">pen</a> for you to fiddle around.</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
