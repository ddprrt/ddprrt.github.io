<!doctype html>
<html>
<head>
</head>
<body>
    <p>If you follow me you know that I’m super late to the React game. It was not until functional components showed up that I got<br>
really interested in the framework. I just loved the idea of having everything wrapped in an easy function rather than needing<br>
to navigate up and down a class to get everything together. One thing that put me off in the beginning though was JSX. And I’m<br>
sure I’m not the only one. Every time I talk to people about my newly found React love, this point comes up constantly.</p>
<p>“JSX mixes HTML with my JavaScript, that’s ugly!”</p>
<p>Except that JSX doesn’t. Here’s what JSX is not:</p>
<ul>
<li>JSX is not a templating language</li>
<li>JSX is not HTML</li>
<li>JSX is not XML</li>
</ul>
<p>JSX <em>looks</em> like all that, but it’s nothing but syntactic sugar.</p>
<h2>JSX is function calls</h2>
<p>JSX translates into pure, nested function calls. The React method signature of JSX is <code>(element, properties, ...children)</code>.<br>
With element being either a React component or a string, properties being a JS object with keys and values. Children being empty, or<br>
an array with more function calls.</p>
<p>So:</p>
<pre><code class="language-javascript">&lt;Button onClick={() =&gt; alert('YES')}&gt;Click me&lt;/Button&gt;
</code></pre>
<p>translates to:</p>
<pre><code class="language-javascript">React.createElement(Button, { onClick: () =&gt; alert('YES') }, 'Click me');
</code></pre>
<p>With nested elements, it looks something like this:</p>
<p>This JSX</p>
<pre><code class="language-javascript">&lt;Button onClick={() =&gt; alert('YES')}&gt;&lt;span&gt;Click me&lt;/span&gt;&lt;/Button&gt;
</code></pre>
<p>translates to:</p>
<pre><code class="language-javascript">React.createElement(Button, { onClick: () =&gt; alert('YES') }, 
  React.createElement('span', {}, 'Click me'));
</code></pre>
<p>What are the implications of that, especially compared to templates?</p>
<ul>
<li>There’s no runtime compilation and parsing of templates. Everything goes directly to the virtual DOM or layout engine underneath.<br>
That’s why it also works with Vue.js so well.</li>
<li>There’s no expressions to evaluate. Everything around is JavaScript.</li>
<li>Every component property is translatable to a JSX object key. This allows us to type check them. TypeScript works so well with JSX<br>
because there’s JavaScript underneath.</li>
</ul>
<p>So everything <em>looks</em> like XML, except that it’s JavaScript functions. If you are a seasoned web developer like I am, think like that:<br>
Ever wanted to write to the DOM directly, but gave up because it’s so unwieldy? Come on, <code>document.createElement</code> is probably easy,<br>
but you have to do a ton of calls to the DOM API to get what you can achieve so easily by writing HTML.</p>
<p>JSX solves that. With JSX you have a nice and familiar syntax of writing elements without HTML.</p>
<h2>Writing the DOM with JSX</h2>
<p>I mentioned TypeScript earlier. TypeScript is a full blown JSX compiler.<br>
With TypeScript, we have the possibility to change the JSX factory. That’s how<br>
TypeScript is able to compile JSX for React, Vue.js, Dojo… any other framework using JSX in one way or the other.<br>
The virtual DOM implementations underneath might differ, but the interface is the same:</p>
<pre><code class="language-javascript">/**
 * element: string or component
 * properties: object or null
 * ...children: null or calls to the factory
 */
function factory(element, properties, ...children) { ... }
</code></pre>
<p>We can use the same factory method signature not only to work with the virtual DOM, we can also use this to work with the real DOM.<br>
Just to have a nice API on top of <code>document.createElement</code>.</p>
<p>Let’s try! These are the features we want to implement:</p>
<ol>
<li>Parse JSX to DOM nodes, including attributes</li>
<li>Have simple, functional components for more composability and flexibility.</li>
</ol>
<p>Step 1: TypeScript needs to know how to compile JSX for us. Setting two properties in <code>tsconfig.json</code> is all we need.</p>
<pre><code class="language-javascript">{
  &quot;compilerOptions&quot;: {
    ...
    &quot;jsx&quot;: &quot;react&quot;,
    &quot;jsxFactory&quot;: &quot;DOMcreateElement&quot;,
  }
}
</code></pre>
<p>We leave it to the React JSX pattern (the method signature we were talking earlier), but tell TypeScript to use our soon to be<br>
created function <code>DOMcreateElement</code> for that.</p>
<p>Next, we implement our factory function. This is just a couple lines of code, so I’ll leave everything here and have<br>
detailed comments below:</p>
<pre><code class="language-javascript">/**
 * A helper function that ensures we won't work with null values
 */
function nonNull(val, fallback) { return Boolean(val) ? val : fallback };

/**
 * How do we handle children. Children can either be:
 * 1. Calls to DOMcreateElement, returns a Node
 * 2. Text content, returns a Text
 * 
 * Both can be appended to other nodes.
 */
function DOMparseChildren(children) {
  return children.map(child =&gt; {
    if(typeof child === 'string') {
      return document.createTextNode(child);
    }
    return child;
  })
}

/**
 * How do we handle regular nodes.
 * 1. We create an element
 * 2. We apply all properties from JSX to this DOM node
 * 3. If available, we append all children.
 */
function DOMparseNode(element, properties, children) {
  const el = document.createElement(element);
  Object.keys(nonNull(properties, {})).forEach(key =&gt; {
      el[key] = properties[key];
  })
  DOMparseChildren(children).forEach(child =&gt; {
    el.appendChild(child);
  });
  return el;
}

/**
 * Our entry function.
 * 1. Is the element a function, than it's a functional component.
 *    We call this function (pass props and children of course)
 *    and return the result. We expect a return value of type Node
 * 2. If the element is a string, we parse a regular node
 */
function DOMcreateElement(element, properties, ...children) {
  if(typeof element === 'function') {
    return element({
      ...nonNull(properties, {}),
      children
    });
  }
  return DOMparseNode(element, properties, children);
}
</code></pre>
<p>To sum it up:</p>
<ol>
<li>The factory function takes elements. Elements can be of type string or a function.</li>
<li>A function element is a component. We call the function, because we expect to get a<br>
DOM Node out of it. If the function component has also more function components inside, they<br>
will eventually resolve to a DOM Node at some point</li>
<li>If the element is a string, we create a regular DOM Node. For that we call <code>document.createElement</code></li>
<li>All properties are passed to the newly created Node. Now you might understand why React has something like<br>
<code>className</code> instead of <code>class</code>. This is because the DOM API underneath is also <code>className</code>. <code>onClick</code> is<br>
camel-case, though, which I find a little odd.</li>
<li>Our implementation only allows DOM Node properties in our JSX, because of that simple property passing</li>
<li>If our component has children (pushed together in an array), we parse children as well and append them.</li>
<li>Children can be either a call to <code>DOMcreateElement</code>, resolving in a DOM Node eventually. Or a simple string.</li>
<li>If it’s a string, we create a <code>Text</code>. <code>Text</code>s can also be appended to a DOM Node.</li>
</ol>
<p>That’s all there is! Look at the following code example:</p>
<pre><code class="language-javascript">const Button = ({ msg }) =&gt; {
  return &lt;button onclick={() =&gt; alert(msg)}&gt;
    &lt;strong&gt;Click me&lt;/strong&gt;
  &lt;/button&gt;
}

const el = &lt;div&gt;
  &lt;h1 className=&quot;what&quot;&gt;Hello world&lt;/h1&gt;
  &lt;p&gt;
    Lorem ipsum dolor sit, amet consectetur 
    adipisicing elit. Quae sed consectetur 
    placeat veritatis 
    illo vitae quos aut unde doloribus, minima eveniet et 
    eius voluptatibus minus aperiam 
    sequi asperiores, odio ad?
  &lt;/p&gt;
  &lt;Button msg='Yay' /&gt;
  &lt;Button msg='Nay' /&gt;
&lt;/div&gt;

document.body.appendChild(el);
</code></pre>
<p>Our JSX implementation returns a DOM Node with all its children. We can even use function components for it.<br>
Instead of templates, we work with the DOM directly. But the API is a lot nicer!</p>
<h2>Bottom line</h2>
<p>JSX is syntactic sugar for function calls. This allows us to work with the DOM or virtual DOM directly, without any<br>
detours. This is also what makes JSX so powerful, even if it’s so simple: All around and inside is JavaScript. You can<br>
be as expresssive as you can be with JavaScript, you are not limited to any templating language.</p>
<p>This also means that JSX is just as nice and beautiful to read as the code written with it. Producing bad and unreadable<br>
code can happen to everybody in every programming language. A bit of syntactic sugar won’t help here.</p>
<p>For me, putting together this little example helped me a lot to understand what’s going on behind the scenes. And it made me<br>
appreciate JSX and React a lot more. Now I know that I’m not mixing HTML with JavaScript or something like that. I’m calling<br>
functions. It just has a lot of angle brackets…</p>
<p><em>P.S. You can find the code at <a href="https://github.com/ddprrt/dom-jsx">GitHub</a></em></p>
<p>//include helper/include-by-tag.html tag=“TypeScript” title=“More articles about TypeScript”</p>

</body>
</html>
