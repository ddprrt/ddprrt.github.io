<!doctype html>
<html>
<head>
</head>
<body>
    <p>React typings for TypeScript come with lots of interfaces for all possible HTML elements<br>
out there. But sometimes, your browsers, your frameworks or your code are a little bit ahead of<br>
what‚Äôs possible.</p>
<p>Let‚Äôs say you want to use the latest image features in Chrome, and load your images lazily.<br>
A progressive enhancement, so only browsers which understand what‚Äôs going on know how to<br>
interpret this. Other browsers are robust enough not to care.</p>
<pre><code class="language-html">&lt;img src=&quot;/awesome.jpg&quot; loading=&quot;lazy&quot; alt=&quot;What an awesome image&quot; /&gt;
</code></pre>
<p>Your TypeScript JSX code? Errors.</p>
<pre><code class="language-javascript">function Image({ src, alt }) {
  // üí• Property 'loading' does not exist...
  return &lt;img src={src}
   alt={alt}
   loading=&quot;lazy&quot; /&gt;
}
</code></pre>
<p>To prevent this, we can extend the available interfaces with our own properties. This<br>
feature of TypeScript is called <em>declaration merging</em>.</p>
<p>Create a <code>@types</code> folder and put a <code>jsx.d.ts</code> file in it. Change your TypeScript config<br>
so your compiler options allow for extra types:</p>
<pre><code class="language-javascript">{
  &quot;compilerOptions&quot;: {
    ...
    /* Type declaration files to be included in compilation. */
    &quot;types&quot;: [&quot;@types/**&quot;],
  },
  ...
}
</code></pre>
<p>We re-create the exact module and interface structure:</p>
<ol>
<li>The module is called <code>'react'</code>,</li>
<li>The interface is <code>ImgHTMLAttributes&lt;T&gt; extends HTMLAttributes&lt;T&gt;</code></li>
</ol>
<p>We know that from the original typings. Here, we add the properties we want to have.</p>
<pre><code class="language-javascript">import 'react'

declare module 'react' {
  interface ImgHTMLAttributes&lt;T&gt; extends HTMLAttributes&lt;T&gt; {
    loading?: 'lazy' | 'eager' | 'auto';
  }
}
</code></pre>
<p>And while we are at it, let‚Äôs make sure we don‚Äôt forget alt texts!</p>
<pre><code class="language-diff">import 'react'

declare module 'react' {
  interface ImgHTMLAttributes&lt;T&gt; extends HTMLAttributes&lt;T&gt; {
    loading?: 'lazy' | 'eager' | 'auto';
+   alt: string;
  }
}
</code></pre>
<p>Way better! TypeScript will take the original definition and merge your declarations.<br>
Your autocomplete can give you all available options <em>and</em> will error when you<br>
forget an alt text.</p>
<p>We can use the same method, when we want <code>styled-jsx</code> to be compatible with TypeScript.<br>
TypeScript does not recognize the <code>jsx</code> and <code>global</code> attributes of the <code>style</code> tag.<br>
Let‚Äôs change that:</p>
<pre><code class="language-javascript">declare module 'react' {
  interface StyleHTMLAttributes&lt;T&gt; extends React.HTMLAttributes&lt;T&gt; {
    jsx?: boolean;
    global?: boolean;
  }
}
</code></pre>
<p>When working with <strong>Preact</strong>, things are a bit more complicated. The original<br>
HTML typings are very generous and not so specific as React‚Äôs typings. That‚Äôs why<br>
we have to be a bit more explicit when defining images:</p>
<pre><code class="language-javascript">declare namespace JSX {
  interface IntrinsicElements {
    &quot;img&quot;: HTMLAttributes &amp; {
      alt: string,
      src: string,
      loading?: 'lazy' | 'eager' | 'auto';
    }
  }
}
</code></pre>
<p>This makes sure that both <code>alt</code> and <code>src</code> are available, and sets and<br>
optional attribute <code>loading</code>.</p>
<p>The technique is the same, though: Declaration merging, which works on namespaces,<br>
interfaces and modules.</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
