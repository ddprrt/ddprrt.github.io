<!doctype html>
<html>
<head>
</head>
<body>
    <p>I recently stumbled upon a question on Reddit‚Äôs <a href="https://www.reddit.com/r/LearnTypescript/">LearnTypeScript</a> subreddit regarding custom React hooks. A user wanted to create a toggle custom hook, and stick to the naming convention as regular React hooks do: Returning an array that you destructure when calling the hook. For example <code>useState</code>:</p>
<pre><code class="language-javascript">const [state, setState] = useState(0)
</code></pre>
<p>Why an array? Because you the array‚Äôs fields have no name, and you can set names on your own:</p>
<pre><code class="language-javascript">const [count, setCount] = useState(0)
const [darkMode, setDarkMode] = useState(true)
</code></pre>
<p>So naturally, if you have a similar pattern, you also want to return an array.</p>
<p>A custom toggle hook might look like this:</p>
<pre><code class="language-javascript">export const useToggle = (initialValue: boolean) =&gt; {
  const [value, setValue] = useState(initialValue)
  const toggleValue = () =&gt; setValue(!value)
  return [value, toggleValue]
}
</code></pre>
<p>Nothing out of the ordinary. The only types we have to set are the types of our input parameters. Let‚Äôs try to use it:</p>
<pre><code class="language-javascript">export const Body = () =&gt; {
  const [isVisible, toggleVisible] = useToggle(false)
  return (
    &lt;&gt;
      {/* It very much booms here! üí• */ }
      &lt;button onClick={toggleVisible}&gt;Hello&lt;/button&gt;
      {isVisible &amp;&amp; &lt;div&gt;World&lt;/div&gt;}
    &lt;/&gt;
  )
}
</code></pre>
<p>So why does this fail? TypeScript‚Äôs error message is very elaborate on this: <em>Type ‚Äòboolean | (() =&gt; void)‚Äô is not assignable to type ‚Äò((event: MouseEvent&lt;HTMLButtonElement, MouseEvent&gt;) =&gt; void) | undefined‚Äô. Type ‚Äòfalse‚Äô is not assignable to type ‚Äò((event: MouseEvent&lt;HTMLButtonElement, MouseEvent&gt;) =&gt; void) | undefined‚Äô.</em></p>
<p>It might be very cryptic. But what we should look out for is the first type, which is declared incompatible: <code>boolean | (() =&gt; void)'</code>. This comes from returning an array. An array is a list of any length, that can hold as many elements as virtually possible. From the return value in <code>useToggle</code>, TypeScript infers an array type. Since the type of <code>value</code> is boolean (great!) and the type of <code>toggleValue</code> is <code>(() =&gt; void)</code> (a function returning nothing), TypeScript tells us that both types are possible in this array.</p>
<p>And this is what breaks the compatibility with <code>onClick</code>. <code>onClick</code> expects a function. Good, <code>toggleValue</code> (or <code>toggleVisible</code>) is a function. But according to TypeScript, it can also be a boolean! Boom! TypeScript tells you to be explicit, or at least do type checks.</p>
<p>But we shouldn‚Äôt need to do extra type-checks. Our code is very clear. It‚Äôs the types that are wrong. Because we‚Äôre not dealing with an array.</p>
<p>Let‚Äôs go for a different name: Tuple. While an array is a list of values that can be of any length, we know exactly how many values we get in a tuple. Usually, we also know the type of each element in a tuple.</p>
<p>So we shouldn‚Äôt return an array, but a tuple at <code>useToggle</code>. The problem: In JavaScript an array and a tuple are indistinguishable. In TypeScript‚Äôs type system, we can distinguish them.</p>
<h2>Option 1: Add a return tuple type</h2>
<p>First possibility: Let‚Äôs be intentional with our return type. Since TypeScript ‚Äì correctly! ‚Äì infers an array, we have to tell TypeScript that we are expecting a tuple.</p>
<pre><code class="language-javascript">// add a return type here
export const useToggle = (initialValue: boolean): [boolean, () =&gt; void] =&gt; {
  const [value, setValue] = useState(initialValue)
  const toggleValue = () =&gt; setValue(!value)
  return [value, toggleValue]
}
</code></pre>
<p>With <code>[boolean, () =&gt; void]</code> as a return type, TypeScript checks that we are returning a tuple in this function. TypeScript does not infer anymore, but rather makes sure that your intended return type is matched by the actual values. And voila, your code doesn‚Äôt throw errors anymore.</p>
<h2>Option 2: as const</h2>
<p>With a tuple, we know how many elements we are expecting, and know the type of these elements. This sounds like a job for freezing the type with a const assertion.</p>
<pre><code class="language-javascript">export const useToggle = (initialValue: boolean) =&gt; {
  const [value, setValue] = useState(initialValue)
  const toggleValue = () =&gt; setValue(!value)
  // here, we freeze the array to a tuple
  return [value, toggleValue] as const
}
</code></pre>
<p>The return type is now <code>readonly [boolean, () =&gt; void]</code>, because <code>as const</code> makes sure that your values are constant, and not changeable. This type is a little bit different semantically, but in reality, you wouldn‚Äôt be able to change the values you return outside of <code>useToggle</code>. So being <code>readonly</code> would be slightly more correct.</p>
<p>And this is, a perfect use case for tuple types! As always, there‚Äôs a <a href="https://www.typescriptlang.org/play/index.html?jsx=2#code/JYWwDg9gTgLgBAJQKYEMDGMA0cDecCuAzkgMowoxIC+cAZlBCHAORSobMBQnSAHpLDhoIAO0LwiSACoQA5rIA2SOAF44ACmAjgMYCgUA1ffiQAuOACMIEJShEBKcwG0rN1COzr7qgHxwAbhDAACYAur64nHBCouJwTv7GSNjEMEYKJuFqkmQUSJrauvrpJvZRMWLwMHKKSCXKal4RqfXqAISJGUhl0Www+FAi8Z0m2NXySvWhnFTcPPzQ8MKVBMQAwrEwMhMNGlo6eoZJ5q62DhE45ctxCUkpSGlJWauk5JQFB8VJPRVx47X1VQabwqPwtJLtEbdcp9AZDW5dMY1SZPOAoQi-GAzbh8ARLTZwABCEGCAE8gU1QZFotd4E5gIQDAzgBYlEidkzCCylM9JNtaupaPpiD9YYMNOVogAeHyS6JwKUWfAwapDURrBTANAAaxUOH+k2ZrOoPgAEkgFAoIFKAPRKlWiWXy+U4Bmc7nKABknoVwWA-h8AHVoApgra-QHZs7bU64GUqEA">playground link</a> for you to fiddle around! Have fun!</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
