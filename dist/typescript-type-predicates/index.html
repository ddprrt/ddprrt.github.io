<!doctype html>
<html>
<head>
</head>
<body>
    <p>Type predicates in TypeScript help you narrowing down your types based on conditionals. They‚Äôre similar to type guards, but work on functions.<br>
They way the work is, if a function returns true, change the type of the paramter to something more useful.</p>
<p>Let‚Äôs start with a basic example. Let‚Äôs say you have a function that checks if a certain value is of type string:</p>
<pre><code class="language-javascript">function isString(s) {
  return typeof s === 'string';
}
</code></pre>
<p>Use the <code>isString</code> function inside another function:</p>
<pre><code class="language-javascript">function toUpperCase(x: unknown) {
  if(isString(x)) {
    x.toUpperCase(); // ‚ö°Ô∏è x is still of type unknown
  }
}
</code></pre>
<p>TypeScript throws an error. We can be sure that <code>x</code> is of type string at this point. But since the validation is wrapped in<br>
a function, the type of <code>x</code> does not change (as opposed to type guards). Enter type predicates.</p>
<p>Let‚Äôs tell TypeScript explicitly that if <code>isString</code> evaluates to true, the type of the parameter is a string:</p>
<pre><code class="language-javascript">function isString(s): s is string {
  return typeof s === 'string';
}
</code></pre>
<p>TypeScript now knows that we are dealing with strings in our <code>toUpperCase</code> function.</p>
<pre><code class="language-javascript">function toUpperCase(x: unknown) {
  if(isString(x)) {
    x.toUpperCase(); // ‚úÖ all good, x is string
  }
}
</code></pre>
<p>See that in the <a href="https://www.typescriptlang.org/play/index.html#src=function%20isString(s)%3A%20s%20is%20string%20%7B%0D%0A%20%20return%20typeof%20s%20%3D%3D%3D%20'string'%3B%0D%0A%7D%0D%0A%0D%0Afunction%20toUpperCase(x%3A%20unknown)%20%7B%0D%0A%20%20if(isString(x))%20%7B%0D%0A%20%20%20%20x.toUpperCase()%3B%20%2F%2F%20%E2%9A%A1%EF%B8%8F%0D%0A%20%20%7D%0D%0A%7D">TypeScript playground</a>;</p>
<h2>Narrowing down sets</h2>
<p>This not only helps you for unknown types, or multiple types, but also to narrow down sets within a type. Let‚Äôs have a program where<br>
you throw a dice. Every time you throw a Six, you win.</p>
<pre><code class="language-javascript">function pipsAreValid(pips: number) {
  // we check for every discrete value, as number can 
  // be something between 1 and 2 as well.
  return pips === 1 || pips === 2 || pips === 3 ||
    pips === 4 || pips === 5 || pips === 6;
}

function evalThrow(count: number) {
  if (pipsAreValid(count)) {
    // my types are lying üò¢
    switch (count) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        console.log('Not today');
        break;
      case 6:
        console.log('Won!');
        break;
      case 7:
        // TypeScript does not complain here, even though
        // it's impossible for count to be 7
        console.log('This does not work!');
        break;
    }
  }
}
</code></pre>
<p>The program looks good at first, but has some issues from a type perspective: <code>count</code> is of type number. This is ok as an input<br>
parameter. Right away we validate that <code>count</code> is a number between 1 and 6. Once we validate this, <code>count</code> is not <em>any</em> number anymore.<br>
It‚Äôs narrowed down to a discrete set of six values.</p>
<p>So starting from the switch statement, my types are lying! To prevent any further complications, let‚Äôs narrow down the set of numbers<br>
to those six discrete values, using union types:</p>
<pre><code class="language-javascript">type Dice = 1 | 2 | 3 | 4 | 5 | 6;

function pipsAreValid(pips: number): pips is Dice {
  return pips === 1 || pips === 2 || pips === 3 ||
    pips === 4 || pips === 5 || pips === 6;
}

function evalThrow(count: number) {
  if (pipsAreValid(count)) {
    // count is now of type Dice üòé
    switch (count) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        console.log('Not today');
        break;
      case 6:
        console.log('Won!');
        break;
      case 7:
        // TypeScript errors here. 7 is not in the union type of 
        // Dice
        console.log('This does not work!');
        break;
    }
  }
}
</code></pre>
<p>A lot type safer for us, and for our colleagues. Of course this ‚Äútype casts‚Äù can be anything that makes sense to strengthen your<br>
applications. Even if you validate complex objects, you can narrow down your parameters to a specific type and make sure they<br>
get along with the rest of your code. Useful, especially if you rely on a lot of functions.</p>
<p>//include helper/include-by-tag.html tag=‚ÄúTypeScript‚Äù title=‚ÄúMore articles about TypeScript‚Äù</p>

</body>
</html>
